[{"categories":["json"],"content":"一、前言 其实本篇应该写的是json的反序列化，所以花了几个晚上看了下该部分源码，每次看都想睡觉。为什么呢？因为确实是太无聊了，我打赌这是我看过go源码中最无聊的逻辑，全篇都是一些状态的切换，要么是 if ... else ... ，要么就是 switch ... case ... case ...,头大。我也尝试画过流程图，但是这么多状态的切换，也不知道是什么力量支撑我画了2天时间，最后我放弃了-画出来没有丝毫意义。所以本篇我就源码层面顺着json：你或许还不知道的使用的坑（一）续写下反序列化可能会遇到的一些坑或者未知的使用方法。 ","date":"2020-12-26","objectID":"/2020/12/26/go-sourcecode-json-unmarshal/:0:0","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json"],"content":"tips: 我在看的过程中也留了些注释，看兴趣的话可以去GitHub上去看看，也欢迎你的加入。 所有代码在 The Go Playground都能看到。 二、内容 ","date":"2020-12-26","objectID":"/2020/12/26/go-sourcecode-json-unmarshal/:1:0","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json"],"content":"1.反序列化科学计数法 假如你有这么个json字符串，如何序列化呢？ { \"Name\": \"zhangSan\", \"Age\": -0e+10000 } 注意Age字段的值并没有被双引号包围，所以go提供了一种类型json.Number专门用来装数字，包括科学计数法和普通数字。下面是我的结构体： type User struct { Name string Age json.Number } 运行我的示例代码能得到正确结果： {zhangSan -0e+10000} ","date":"2020-12-26","objectID":"/2020/12/26/go-sourcecode-json-unmarshal/:2:0","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json"],"content":"2.value是null的注意 假如我有这么个json字符串： { \"Name\": null, \"Age\": null } 且我的结构体是这样的： type User struct { Name string Age map[string]string } 我的序列化代码如下: var san = User{ Name: \"aaa\", Age: map[string]string{\"1\": \"1\"}, } err := json.Unmarshal(bytes, \u0026san) if err != nil { fmt.Println(\"error:\", err) } else { fmt.Println(san) } 你觉得打印结果会是神马样子的呢？ {aaa map[]} 会有点不可思议是吧？为什么Name的值没有改变，但是Age确被重新初始化了呢？ go的官方序列化代码如下: case 'n': // null // The main parser checks that only true and false can reach here, // but if this was a quoted string input, it could be anything. if fromQuoted \u0026\u0026 string(item) != \"null\" { // 字段有',string'标签，以n开头，必须是null d.saveError(fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal %q into %v\", item, v.Type())) break } switch v.Kind() { case reflect.Interface, reflect.Ptr, reflect.Map, reflect.Slice: // 设置给interface{},指针,map,切片一个初始化的值 v.Set(reflect.Zero(v.Type())) // otherwise, ignore null for primitives/string } ok,能看到10~12行把该字段重新设置为0值了,不仅map,还有interface,指针,slice都会发生这种情况，除了这种情况，其他的值都不会被改变。 ","date":"2020-12-26","objectID":"/2020/12/26/go-sourcecode-json-unmarshal/:3:0","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json"],"content":"3.反序列到接口，必须是空接口 常理任何json字段都可以序列化到接口的，但是需要注意下，go只允许空接口 interface{}，如果你的接口有方法的话是不被允许的。例如你有如下结构体： type User struct { Name string Age interface { GetAge() int } } 可以看到 Age字段是一个非空接口，当我反序列化该json字符串的时候： { \"Name\": null, \"Age\": 19 } 会发生异常,示例代码： error: json: cannot unmarshal number into Go struct field User.Age of type interface { GetAge() int } go的代码在这里: case reflect.Interface: if v.NumMethod() == 0 { // 空接口 v.Set(reflect.ValueOf(value)) } else { // 非空接口 d.saveError(\u0026UnmarshalTypeError{Value: \"bool\", Type: v.Type(), Offset: int64(d.readIndex())}) // 接口 } v.NumMethod() == 0表示必须是个空接口。 三、另外一种装逼的反序列方式 你可知除了json.Unmarshal()这种方式，还有另外一种反序列的编码方式: var data = []byte (` { \"Name\": \"zhangSan\", \"Age\": 19 } `) var san = User{ } decoder := json.NewDecoder(bytes.NewReader(data)) decoder.Decode(\u0026san) if err != nil { fmt.Println(\"error:\", err) } else { fmt.Println(san) } 当然装逼不是目的，目的是我们能做更多的反序列化的行为控制. ","date":"2020-12-26","objectID":"/2020/12/26/go-sourcecode-json-unmarshal/:4:0","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json"],"content":"1.把数字当做json.Number类型反序列化到接口里面去 这样有什么意义呢？因为go的做法是默认把数字反序列化成float64类型，但是当该数字很大的时候，float64是表示不了的，所以此时就要用json.Number，但是用json.Unmarshal()是做不到的，此时用json.NewDecoder()就可以的。 下面是错误的示例代码： type User struct { Name string Age interface{} } func main() { var data = []byte (` { \"Name\": \"zhangSan\", \"Age\": 2e+1000 } `) var san = User{ } decoder := json.NewDecoder(bytes.NewReader(data)) //decoder.UseNumber() err := decoder.Decode(\u0026san) if err != nil { fmt.Println(\"error:\", err) } else { fmt.Println(san) } } 错误结果如下： error: json: cannot unmarshal number 2e+1000 into Go struct field User.Age of type float64 只需要把第16行的代码取消注释即可达到目的。 让我们看看go的源码说明: // UseNumber causes the Decoder to unmarshal a number into an interface{} as a // Number instead of as a float64. func (dec *Decoder) UseNumber() { dec.d.useNumber = true } 注释已经讲的很明白了。 再看看具体怎么使用useNumber这个参数的： // convertNumber converts the number literal s to a float64 or a Number // depending on the setting of d.useNumber. func (d *decodeState) convertNumber(s string) (interface{}, error) { if d.useNumber { return Number(s), nil } f, err := strconv.ParseFloat(s, 64) if err != nil { return nil, \u0026UnmarshalTypeError{Value: \"number \" + s, Type: reflect.TypeOf(0.0), Offset: int64(d.off)} } return f, nil } 第4~5行也说明了使用json.Number类型获得结果。 ","date":"2020-12-26","objectID":"/2020/12/26/go-sourcecode-json-unmarshal/:5:0","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json"],"content":"2.当json字符串某个字段没有在结构体中对应的时候 默认情况下json是允许这种情况下的，那如何禁止这种情况呢？ 这是我的结构体： type User struct { Name string Age interface{} } 我的json字符串： { \"Name\": \"zhangSan\", \"Age\": 2e+1000, \"Head\": \"http://head.jpg\" } 我的反序列化代码: var san = User{ } decoder := json.NewDecoder(bytes.NewReader(data)) decoder.UseNumber() decoder.DisallowUnknownFields() err := decoder.Decode(\u0026san) if err != nil { fmt.Println(\"error:\", err) } else { fmt.Println(san) } 结果会报错，提示找不到Head字段： error: json: unknown field \"Head\" json的源码在这里： if d.disallowUnknownFields { // 判断是否允许没有字段可序列化的情况 d.saveError(fmt.Errorf(\"json: unknown field %q\", key)) } 三、参考","date":"2020-12-26","objectID":"/2020/12/26/go-sourcecode-json-unmarshal/:6:0","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":[],"content":"一、前言 跟着 Protocol Buffers 官方学习 What are protocol buffers? Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages. Google 用来序列化结构数据，具有语言中立、平台中立和可扩展机制。比XML更小、更快、更简单。定义一次数据结构后，用特定语言的源码成功工具创建各个语言的代码。 ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:1:0","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"二、proto2 ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:2:0","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"2.1 定义消息类型 定义类型 message SearchRequest { required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3;} 可分配字段编号 最小数字 1，最大数字 2^29 - 1, or 536,870,911 范围为1到15的字段编号需要一个字节来编码，16到2047之间的字段号占用两个字节，应该为非常频繁出现的消息元素保留字段编号1到15 不能使用数字19000到19999（FieldDescriptor::kFirstReservedNumber至FieldDescriptor::kLastReservedNumber） 指定字段规则 required: 必须存在值的字段 optional: 可选字段，能够存在值或者为空的字段 repeated: 数组类型，可以放空或者值. 数组值的顺序会被保护（不改变） 使用 required 要小心，从 required 改 optional 可能会导致使用者出错。有些人甚至认为它的害处大于利处。 定义多个类型 一个 .proto 文件可以定义多个类，但是会导致消息膨胀，建议把不同类型的消息定义到不同的 .proto 文件 添加注解 /* SearchRequest represents a search query, with pagination options to * indicate which results to include in the response. */message SearchRequest { required string query = 1; optional int32 page_number = 2; // Which page number do we want? optional int32 result_per_page = 3; // Number of results to return per page. } 设置字段备用 message Foo { reserved 2, 15, 9 to 11; reserved \"foo\", \"bar\";} 不建议直接删除字段，容易引起异常。可以把字段设置成备用。 通过 .proto 生成文件 C++，生成 .h 和 .cc 文件 Java，生成 .java 文件 Python，作为 metaclass 不懂嘻嘻 Go，生成 .pb.go 文件 ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:2:1","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"2.2 标准值类型 直接上图 .proto Type Notes C++ Type Java Type Python Type[2] Go Type double double double float *float64 float float float float *float32 int32 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead. int32 int int *int32 int64 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead. int64 long int/long[3] *int64 uint32 Uses variable-length encoding. uint32 int[1] int/long[3] *uint32 uint64 Uses variable-length encoding. uint64 long[1] int/long[3] *uint64 sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int *int32 sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long[3] *int64 fixed32 Always four bytes. More efficient than uint32 if values are often greater than 228. uint32 int[1] int/long[3] *uint32 fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 256. uint64 long[1] int/long[3] *uint64 sfixed32 Always four bytes. int32 int int *int32 sfixed64 Always eight bytes. int64 long int/long[3] *int64 bool bool boolean bool *bool string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String unicode (Python 2) or str (Python 3) *string bytes May contain any arbitrary sequence of bytes. string ByteString bytes []byte ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:2:2","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"2.3 可选字段的默认值 optional int32 result_per_page = 3 [default = 10]; 对于字符串，默认值为空字符串。对于字节，默认值为空字节字符串。对于布尔值，默认值为false。对于数字类型，默认值为零。对于枚举，默认值为枚举类型定义中列出的第一个值。 ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:2:3","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"2.4 枚举 标准用法 message SearchRequest { required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3 [default = 10]; enum Corpus { UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; } optional Corpus corpus = 4 [default = UNIVERSAL];} 给枚举取别名，加上 option allow_alias = true enum EnumAllowingAlias { option allow_alias = true; UNKNOWN = 0; STARTED = 1; RUNNING = 1;}enum EnumNotAllowingAlias { UNKNOWN = 0; STARTED = 1; // RUNNING = 1; // Uncommenting this line will cause a compile error inside Google and a warning message outside. } 保留值 enum Foo { reserved 2, 15, 9 to 11, 40 to max; reserved \"FOO\", \"BAR\";} 不能在同reserved一条语句中混合使用字段名和数字值 ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:2:4","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"2.5 使用其它消息类型 同一个文件 message SearchResponse { repeated Result result = 1;}message Result { required string url = 1; optional string title = 2; repeated string snippets = 3;} 不是同一个文件 import \"myproject/other_protos.proto\"; 文件转移 // new.proto // All definitions are moved here // old.proto // This is the proto that all clients are importing. import public \"new.proto\";import \"other.proto\"; // client.proto import \"old.proto\";// You use definitions from old.proto and new.proto, but not other.proto ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:2:5","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"2.6 嵌套类型 标准例子 message SearchResponse { message Result { required string url = 1; optional string title = 2; repeated string snippets = 3; } repeated Result result = 1;} 其它类型嵌套 message SomeOtherMessage { optional SearchResponse.Result result = 1;} 你可以多层嵌套 message Outer { // Level 0 message MiddleAA { // Level 1 message Inner { // Level 2 required int64 ival = 1; optional bool booly = 2; } } message MiddleBB { // Level 1 message Inner { // Level 2 required int32 ival = 1; optional bool booly = 2; } }} ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:2:6","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"2.7 更新消息类型 不要更改任何现有字段的字段编号。 您添加的任何新字段应为optional或repeated。这意味着任何使用“旧”消息格式通过代码序列化的消息都可以被新生成的代码解析，因为它们不会丢失任何required元素。您应该为这些元素设置合理的默认值，以便新代码可以与旧代码生成的消息正确交互。同样，由新代码创建的消息可以由旧代码解析：旧的二进制文件在解析时只会忽略新字段。但是，未知字段不会被丢弃，并且如果消息在以后进行序列化，则未知字段也会与之一起进行序列化–因此，如果消息传递给新代码，则新字段仍然可用。 只要在更新的消息类型中不再使用该字段号，就可以删除不需要的字段。您可能想要重命名该字段，或者添加前缀“ OBSOLETE_”，或者将字段编号保留为，以便将来的用户.proto不会意外地重用该编号。 只要类型和数字保持不变，就可以将不需要的字段转换为扩展名，反之亦然。 int32，uint32，int64，uint64，和bool都是兼容的-这意味着你可以在现场从这些类型到另一种改变不破坏forwards-或向后兼容。如果从对应的类型不适合的导线中解析出一个数字，则将获得与在C ++中将数字强制转换为该类型一样的效果（例如，如果将64位数字读取为int32，它将被截断为32位）。 sint32并且sint64彼此兼容，但与其他整数类型不兼容。 string并且bytes只要字节是有效的UTF-8即可兼容。 bytes如果字节包含消息的编码版本，则嵌入式消息与之兼容。 fixed32与兼容sfixed32，并fixed64用sfixed64。 对于string，bytes和消息字段，optional与兼容repeated。给定重复字段的序列化数据作为输入，如果期望该字段optional是原始类型字段，则期望该字段的客户端将采用最后一个输入值；如果是消息类型字段，则将合并所有输入元素。请注意，这对于数字类型（包括布尔值和枚举）通常并不安全。重复的数字类型字段可以以打包格式序列化，当需要一个optional字段时，将无法正确解析该格式。 只要您记住从未通过网络发送默认值，通常就可以更改默认值。因此，如果程序收到未设置特定字段的消息，则该程序将看到该程序协议版本中定义的默认值。它不会看到在发送者的代码中定义的默认值。 enum与兼容int32，uint32，int64，和uint64电线格式条款（请注意，如果他们不适合的值将被截断），但是要知道，客户端代码可以区别对待反序列化的消息时。值得注意的是，enum当对消息进行反序列化时，无法识别的值将被丢弃，这会使字段的has..访问器返回false，并且其getter返回enum定义中列出的第一个值；如果指定了默认值，则返回默认值。对于重复的枚举字段，所有无法识别的值将从列表中删除。但是，整数字段将始终保留其值。因此，在将整数升级为a时，enum在接收在线上的枚举枚举值方面需要非常小心。 在当前的Java和C ++实现中，当enum去除了无法识别的值时，它们会与其他未知字段一起存储。请注意，如果将此数据序列化然后由识别这些值的客户端重新解析，则可能导致奇怪的行为。对于可选字段，即使在反序列化原始消息后写入了新值，识别该值的客户端仍会读取旧值。在重复字段的情况下，旧值将出现在任何已识别的值和新添加的值之后，这意味着将不保留顺序。 将单个optional值更改为新 值的成员oneof是安全且二进制兼容的。如果您确定没有代码一次设置多个optional字段，那么将多个字段移动到新字段中oneof可能是安全的。将任何字段移到现有字段中oneof都是不安全的。 在map\u003cK, V\u003e和对应的repeated消息字段之间更改字段是二进制兼容的（有关消息布局和其他限制，请参见下面的Maps）。但是，更改的安全性取决于应用程序：在反序列化和重新序列化消息时，使用repeated字段定义的客户端将产生语义上相同的结果；但是，使用map字段定义的客户端可以对条目进行重新排序，并删除具有重复键的条目。 ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:2:7","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"2.8 扩展名 标准用法 message Foo { // ... extensions 100 to 199;} extend Foo { optional int32 bar = 126;} 实际例子待补充 嵌套扩展 message Baz { extend Foo { optional int32 bar = 126; } ...} 实际例子待补充 ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:2:8","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"2.9 一个 标准使用 message SampleMessage { oneof test_oneof { string name = 4; SubMessage sub_message = 9; }} oneof特性 设置oneof字段将自动清除oneof的所有其他成员。因此，如果您设置了多个字段，则只有您设置的最后一个字段仍具有值 如果解析器在线路上遇到同一个对象的多个成员，则在解析的消息中仅使用最后看到的成员。 其中之一不支持扩展。 一个不能是repeated。 反射API适用于其中一个字段。 如果将oneof字段设置为默认值（例如将int32 oneof字段设置为0），则将设置该oneof字段的“大小写”，并且该值将在线路上序列化。 向后兼容问题 添加或删除字段之一时请多加注意。如果检查oneof的值返回None/ NOT_SET，则可能意味着尚未设置oneof或已将其设置为不同版本的oneof中的字段。由于无法知道导线上的未知字段是否是oneof的成员，因此无法分辨出差异。 ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:2:9","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"2.10 Maps ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:2:10","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"2.11 Packages ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:2:11","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"2.12 定义服务 ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:2:12","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"2.13 Options ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:2:13","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"2.14 生成你的类 ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:2:14","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"三、proto3 ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:3:0","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":[],"content":"四、参考 https://developers.google.com/protocol-buffers/docs/overview ","date":"2020-12-18","objectID":"/notes/what-is-protocol-buffers/:4:0","tags":[],"title":"Protocol Buffers | Language Guide(proto2)","uri":"/notes/what-is-protocol-buffers/"},{"categories":["go源码"],"content":"本文是 map 源码系列第一篇，带你走进 map 为什么分析map 在计算机编程语言当中，用的最多的数据结构估计就是map。map以他近乎o(1)的查找效率和修改效率让他在大多数场景下都比较受青睐。map的常规的实现方式都是hash+其他数据结构，如java是hash+红黑树，而我现在即将要分析的go的实现方式是hash+链表。我会分析map的几乎每段代码，并且在我的GitHub可以查看到我的分析，注释十分详尽，欢迎批评指正。我的打算是把一些常用的数据结构都分析一遍，如果有志同道合的人，可以联系我。 ","date":"2020-11-25","objectID":"/2020/11/25/go-sourcecode-map-first/:0:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"我的环境 为了给那些感兴趣看源码分析我的博客的同学阅读得更加清晰，列举了我的环境： go1.14.7 amd64； windows和mac接口，linux没有测试，估计没问题 ； goland,目前最好的golang ide，虽然笔者用起来感觉还是不太完美； 着重分析map[string]string，其他类型的源码变化不大 ； ","date":"2020-11-25","objectID":"/2020/11/25/go-sourcecode-map-first/:1:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"本篇重点 1.go的map和java的map有区别，go中是一个关键字，而java确实可以直接查看源码，那么如何分析go的map源码？ 2.调试过程当中，go充斥着大量指针，如何知道指针指向的内容？map的最小单位bmap除了查看tophash，怎么查看里面的其他隐藏字段？ 3.go的map源码为何给不同的key的类型设计不同的实现？ 4.其他一些查看源码的小技巧：内存对齐、指针偏移、类型大小等等 ","date":"2020-11-25","objectID":"/2020/11/25/go-sourcecode-map-first/:2:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"如何找到map对应的源码 go的map的结构体是hmap，代码位于runtime/map.go,当编译器编译你申明使用map的源码时候，其实是使用了runtime/map*.go,后面对map的增删改查都是执行该代码，故要弄懂map的底层原理只需要分析该源码，也可以断点调试。 我下面有个自己测试的源码，注意我编译之后查看，就可以发现端倪： package main import \"fmt\" func main() { m1 := make(map[string]string) fmt.Println(m1) m2 := make(map[string]string, 8) fmt.Println(m2) m3 := make(map[string]string, 9) fmt.Println(m3) m4 := map[string]string{} fmt.Println(m4) m3[\"1\"] = \"2\" for k, v := range m3 { fmt.Println(k) fmt.Println(v) } v1 := m3[\"1\"] fmt.Println(v1) if v2, ok := m3[\"1\"]; ok { fmt.Println(v2) } } 上面代码有几种不同申明map的方式，对应runtime/map.go也不同。还有赋值和遍历查找的代码。 下面编译得到汇编指令文件，执行 go tool compile -N -l -S main.go \u003e main.txt 生成了汇编指令文件: \"\".main STEXT size=1891 args=0x0 locals=0x288 0x0000 00000 (main.go:5) TEXT \"\".main(SB), ABIInternal, $648-0 0x0000 00000 (main.go:5) MOVQ TLS, CX 0x0009 00009 (main.go:5) PCDATA $0, $-2 0x0009 00009 (main.go:5) MOVQ (CX)(TLS*2), CX 0x0010 00016 (main.go:5) PCDATA $0, $-1 0x0010 00016 (main.go:5) LEAQ -520(SP), AX 0x0018 00024 (main.go:5) CMPQ AX, 16(CX) 0x001c 00028 (main.go:5) PCDATA $0, $-2 0x001c 00028 (main.go:5) JLS 1881 0x0022 00034 (main.go:5) PCDATA $0, $-1 0x0022 00034 (main.go:5) SUBQ $648, SP 0x0029 00041 (main.go:5) MOVQ BP, 640(SP) 0x0031 00049 (main.go:5) LEAQ 640(SP), BP 0x0039 00057 (main.go:5) PCDATA $0, $-2 0x0039 00057 (main.go:5) PCDATA $1, $-2 0x0039 00057 (main.go:5) FUNCDATA $0, gclocals·ad6397d3d33bbb6a31b1320349e23274(SB) 0x0039 00057 (main.go:5) FUNCDATA $1, gclocals·1bbf1965a34fa71a63e073b1cf2d752a(SB) 0x0039 00057 (main.go:5) FUNCDATA $2, gclocals·658035074399f748be6dd39603d5113c(SB) 0x0039 00057 (main.go:5) FUNCDATA $3, \"\".main.stkobj(SB) 0x0039 00057 (main.go:6) PCDATA $0, $0 0x0039 00057 (main.go:6) PCDATA $1, $0 0x0039 00057 (main.go:6) CALL runtime.makemap_small(SB) 0x003e 00062 (main.go:6) PCDATA $0, $1 0x003e 00062 (main.go:6) MOVQ (SP), AX 0x0042 00066 (main.go:6) MOVQ AX, \"\".m1+80(SP) 0x0047 00071 (main.go:7) PCDATA $0, $0 0x0047 00071 (main.go:7) PCDATA $1, $1 0x0047 00071 (main.go:7) MOVQ AX, \"\"..autotmp_10+200(SP) 0x004f 00079 (main.go:7) PCDATA $1, $2 0x004f 00079 (main.go:7) XORPS X0, X0 0x0052 00082 (main.go:7) MOVUPS X0, \"\"..autotmp_9+272(SP) 0x005a 00090 (main.go:7) PCDATA $0, $1 0x005a 00090 (main.go:7) PCDATA $1, $1 0x005a 00090 (main.go:7) LEAQ \"\"..autotmp_9+272(SP), AX 0x0062 00098 (main.go:7) MOVQ AX, \"\"..autotmp_15+192(SP) 0x006a 00106 (main.go:7) TESTB AL, (AX) 0x006c 00108 (main.go:7) PCDATA $0, $2 0x006c 00108 (main.go:7) PCDATA $1, $0 0x006c 00108 (main.go:7) MOVQ \"\"..autotmp_10+200(SP), CX 0x0074 00116 (main.go:7) PCDATA $0, $3 0x0074 00116 (main.go:7) LEAQ type.map[string]string(SB), DX 0x007b 00123 (main.go:7) PCDATA $0, $2 0x007b 00123 (main.go:7) MOVQ DX, \"\"..autotmp_9+272(SP) 0x0083 00131 (main.go:7) PCDATA $0, $1 0x0083 00131 (main.go:7) MOVQ CX, \"\"..autotmp_9+280(SP) 0x008b 00139 (main.go:7) TESTB AL, (AX) 0x008d 00141 (main.go:7) JMP 143 0x008f 00143 (main.go:7) MOVQ AX, \"\"..autotmp_14+520(SP) 0x0097 00151 (main.go:7) MOVQ $1, \"\"..autotmp_14+528(SP) 0x00a3 00163 (main.go:7) MOVQ $1, \"\"..autotmp_14+536(SP) 0x00af 00175 (main.go:7) PCDATA $0, $0 0x00af 00175 (main.go:7) MOVQ AX, (SP) 0x00b3 00179 (main.go:7) MOVQ $1, 8(SP) 0x00bc 00188 (main.go:7) MOVQ $1, 16(SP) 0x00c5 00197 (main.go:7) CALL fmt.Println(SB) 0x00ca 00202 (main.go:8) CALL runtime.makemap_small(SB) 0x00cf 00207 (main.go:8) PCDATA $0, $1 0x00cf 00207 (main.go:8) MOVQ (SP), AX 0x00d3 00211 (main.go:8) MOVQ AX, \"\".m2+72(SP) 0x00d8 00216 (main.go:9) PCDATA $0, $0 0x00d8 00216 (main.go:9) PCDATA $1, $1 0x00d8 00216 (main.go:9) MOVQ AX, \"\"..autotmp_10+200(SP) 0x00e0 00224 (main.go:9) PCDATA $1, $2 0x00e0 00224 (main.go:9) XORPS X0, X0 0x00e3 00227 (main.go:9) MOVUPS X0, \"\"..autotmp_9+272(SP) 0x00eb 00235 (main.go:9) PCDATA $0, $1 0x00eb 00235 (main.go:9) PCDATA $1, $1 0x00eb 00235 (main.go:9) LEAQ \"\"..autotmp_9+272(SP), AX 0x00f3 00243 (main.go:9) MOVQ AX, \"\"..autotmp_17+184(SP) 0x00fb 00251 (main.go:9) TESTB AL, (AX) 0x00fd 00253 (main.go:9) PCDATA $0,","date":"2020-11-25","objectID":"/2020/11/25/go-sourcecode-map-first/:3:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"go的map对应的结构体hmap go的map的基础结构体是hmap,在runtime/map.go中， // A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler's definition. // map存储的键值对个数 count int // # live cells == size of map. Must be first (used by len() builtin) // 表示map的一些标志位 flags uint8 // map的桶的2的对数就是B值 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) // 溢出桶个数，是个近似数，不完全相等 noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details // hash种子 hash0 uint32 // hash seed // 桶，真正存数据的地方，2^B个桶 buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. // 保存一些即将迁移的桶 oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing // 从oldbuckets迁移到新的buckets的进度 nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) // 当key不是指针类型的数据的时候，里面会存溢出桶，这样会避免go的扫描 extra *mapextra // optional fields } 既然是map结构体，为何注释说是一个header呢？这是因为buckets和oldbuckets这2个字段并没有真正存取数据，只是存了一个指针，指向存取buckets的地址，故我们在使用过程中拷贝hmap的时候，并没有真正拷贝map的数据，只是拷贝了hmap这个结构体的一些数据。 在看看hmap的字段mapextra: // mapextra holds fields that are not present on all maps. type mapextra struct { // If both key and elem do not contain pointers and are inline, then we mark bucket // 如果key和value都不包括指针并且内敛，然后我们就标记bucket没有指针 // type as containing no pointers. This avoids scanning such maps. // 这样会避免gc扫描 // However, bmap.overflow is a pointer. In order to keep overflow buckets // 但是，虽然key和value不包括指针，但是逸出桶却是个指针，为了让逸出桶一直 // alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow. // 存在，所以就把逸出桶和需要迁移的逸出桶的指针存到hamp的extra字段里面 // overflow and oldoverflow are only used if key and elem do not contain pointers. // 如果key和elme包含指针，overflow和oldoverflow就不会被使用了 // overflow contains overflow buckets for hmap.buckets. // oldoverflow contains overflow buckets for hmap.oldbuckets. // The indirection allows to store a pointer to the slice in hiter. overflow *[]*bmap oldoverflow *[]*bmap // nextOverflow holds a pointer to a free overflow bucket. nextOverflow *bmap } 如mapextra结构体为啥说有些字段并不会在所有map里面全部都有呢？mapextra是一个为了优化bucket而设计的，当key或value是指针的时候，此时overflow和oldoverflow就不会被使用，只有nextOverflow会被使用，该字段保存了预先申请的逸出桶，在没有发生扩容的时候，而一个桶或者说bmap的8个tophash都被使用完了，那么就要考虑使用逸出桶。 当key和value都没有指针的时候bucket的bmap的_type的ptrdata就是0，意味着该结构体是没有指针的，申请bmap内存的时候，会申请一个没有指针的span，这样会避免gc扫描该内存，会提高效率，但是bmap的最后一个内存块是确确实实存放指针的，所以用uintptr存储着该map的逸出桶的地址，但是由于没有指向下一个逸出桶，可能会被gc回收掉，所以就需要overflow存取指向该逸出桶的指针避免被gc回收掉。 overflow和oldoverflow的用处差不多，只是oldoverflow为了迁移使用，后面的系列会详说。 ","date":"2020-11-25","objectID":"/2020/11/25/go-sourcecode-map-first/:4:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"bucket的结构体bmap bmap就是真正存数据的结构体了,bmap在源码中定义十分简单： // A bucket for a Go map. type bmap struct { // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] \u003c minTopHash, // tophash[0] is a bucket evacuation state instead. tophash [bucketCnt]uint8 // Followed by bucketCnt keys and then bucketCnt elems. // NOTE: packing all the keys together and then all the elems together makes the // code a bit more complicated than alternating key/elem/key/elem/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer. } 但其实真正的在内存中分配的结构体是这样的： // A bucket for a Go map. type bmap struct { // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] \u003c minTopHash, // tophash[0] is a bucket evacuation state instead. tophash [bucketCnt]uint8 keys [bucketCnt]string // 由于我举例的key是string，故我这里写string values [bucketCnt]string // 由于上面我的例子的value的类型是string，故这里也是string pointer unsafe.pointer // 由于key和value都是指针，所以这里是一个指针 // Followed by bucketCnt keys and then bucketCnt elems. // NOTE: packing all the keys together and then all the elems together makes the // code a bit more complicated than alternating key/elem/key/elem/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer. } 隐藏的字段在map源码中都是靠地址偏移来得到，tophash我们能轻易找到位置，但是如何找到keys、values和pointer呢？ 在map中是这么做的： dataOffset = unsafe.Offsetof(struct { b bmap v int64 }{}.v) 在64位机器上，需要对齐8个字节，这里int64正好也是8个字节，所以恰好解决内存对齐的问题，找到v的起始地址也就是values的起始地址: dataOffset+bucketCnt*2*sys.PtrSize // string16个字节，相当于2个指针，bucketCnt等于8 pointer的起始地址 dataOffset+bucketCnt*2*sys.PtrSize+sys.PtrSize tophash存的是key的hash高8位，为了方便查找key，为什么keys和values分别存在一堆呢？不是k|v|k|v这种呢？由于key和value的变量类型可能不一样，对齐系数不一致，可能导致内存不紧凑而浪费内存，所以把8个keys存到一堆，8个values存到一堆，然后最后在pointer之前对齐就可以了。所以此时也能算出来整个bmap的大小: bucketCnt*(uint8的字节为1)+bucketCnt*(string的字节16)+bucketCnt*(string的字节16)+指针大小8字节 = 272 在真正调试的时候如查看bucket里面的具体的key和value呢？这里给大家展示一个小技巧，如果大家有其他方法，可以留言讨论： type dmap struct { tophash [bucketCnt]uint8 debugKeys [bucketCnt]string debugElems [bucketCnt]string //debugOverflows unsafe.Pointer debugOverflows uintptr } 这是我定义的调试结构体，将该代码和bmap的结构体放到一堆，当你获取到bmap桶的地址的时候，就可以如下转换，就可以查看bmap的具体值了： b0 := (*dmap)(add(buckets, uintptr(0)*uintptr(t.bucketsize))) println(b0.debugOverflows) buckets假设是桶数组的起始地址，加上bucketsize就会得到第二个桶的起始地址，然后直接转型为*dmap,最后你可以可以打印出来你想查看的真实的值了。 ","date":"2020-11-25","objectID":"/2020/11/25/go-sourcecode-map-first/:5:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"map的整体结构 如果申请内存桶的时候又多余的溢出桶，那么mapextra的nextOverflow就会指向[]bmap其中的某块桶的地址，地址后之后的桶都是溢出桶。在一个桶装不下的时候，会去溢出桶拿桶然后bmap的overflow指向溢出桶。 ","date":"2020-11-25","objectID":"/2020/11/25/go-sourcecode-map-first/:6:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"总结 上面大概介绍了map的数据结构，后面系列map的具体代码分析，包括增、删、改、查、扩容等都会分篇细解，如有不足之处，请共同讨论学习。 ","date":"2020-11-25","objectID":"/2020/11/25/go-sourcecode-map-first/:7:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/2020/11/25/go-sourcecode-map-first/"},{"categories":["Hugo"],"content":"本文介绍如何使 Hugo 博客在 GitHub 自动部署","date":"2020-06-11","objectID":"/2020/06/11/hugo-github-action/","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"一、前言 使用 Hugo 有一些时间了，把内容上传到 GitHub Pages，从一开始的手动操作，到脚本操作，终于来到了自动化部署。 部署的流程： 本地通过 Hugo 命令创建文件，编写博客，编写好后把改变的内容上传到 GitHub 博客源文件仓库。通过 GitHub Action 自动触发脚本构建，然后把静态文件通过 GitHub Deploy 到博客仓库。 ","date":"2020-06-11","objectID":"/2020/06/11/hugo-github-action/:1:0","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"二、具体步骤 ","date":"2020-06-11","objectID":"/2020/06/11/hugo-github-action/:2:0","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.1 创建两个仓库 创建博客源仓库 创建博客静态资源仓库 ","date":"2020-06-11","objectID":"/2020/06/11/hugo-github-action/:2:1","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.2 创建 SSH 需要生成一对 SSH Key，生成的 Public Key 和 Private Key 都会用到。 ssh-keygen -t rsa -b 4096 -C \"ironcity.hz@gmail.com\" Generating public/private rsa key pair. Enter file in which to save the key (/Users/tc/.ssh/id_rsa): 输入你需要指定的文件，比如 /Users/tc/.ssh/id_rsa_hugo_deploy 只是为了防止覆盖之前创建的默认文件 ","date":"2020-06-11","objectID":"/2020/06/11/hugo-github-action/:2:2","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.2 配置博客静态资源仓库的 Deploy Keys 添加公钥到 funnycode-org.github.io 仓库的 Deploy Keys 添加后 ","date":"2020-06-11","objectID":"/2020/06/11/hugo-github-action/:2:3","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.3 配置博客源内容仓库的 Secrets 添加私钥到 blog 仓库的 Secrets 添加后 注意这个 secrets 的名称 ","date":"2020-06-11","objectID":"/2020/06/11/hugo-github-action/:2:4","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.4 编写博客 克隆 blog 项目到本地 # 选取一个目录 cd ~/Desktop/ # 克隆 source 仓库 git clone git@github.com:funnycode-org/blog.git # 进入仓库 cd blog 创建 hugo 博客 # 创建博客，多语言模式 hugo new /posts/[blog-name]/index.zh-cn.md # 运行预览效果 hugo serve -D 如果没有什么问题就可以准备提交代码了 git add . git commit -m \"update commit\" git push -u origin master ","date":"2020-06-11","objectID":"/2020/06/11/hugo-github-action/:2:5","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.5 GitHub Actions 说明 Actions 内容： name: Deploy Hugo Site to Github Pages on Master Branch on: push: branches: - master jobs: build-deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: '0.76.0' # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: funnycode-org/funnycode-org.github.io # remote branch publish_dir: \"./docs\" cname: blog.funnycode.org.cn keep_files: false # remove existing files publish_branch: docs # deploying branch commit_message: ${{ github.event.head_commit.message }} 注意点： publish_dir 指定发布的目录，./docs 指 blog 项目下的 docs 目录下的内容会被发布 publish_branch 发布到 funnycode-org.github.io 项目的 docs 分支 secrets.ACTIONS_DEPLOY_KEY 的 ACTIONS_DEPLOY_KEY 则是上面设置 Private Key 的变量名 cname 必须要配置好，和下文提到的 Setting 里面配置图对应 ","date":"2020-06-11","objectID":"/2020/06/11/hugo-github-action/:2:6","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.7 funnycode-org.github.io 配置 配置 Setting 验证访问 输入 ![https://blog.funnycode.org.cn] (https://blog.funnycode.org.cn)，效果： ","date":"2020-06-11","objectID":"/2020/06/11/hugo-github-action/:2:7","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"三、参考 https://github.com/peaceiris/actions-hugo https://zhuanlan.zhihu.com/p/109057290 https://github.com/peaceiris/actions-gh-pages ","date":"2020-06-11","objectID":"/2020/06/11/hugo-github-action/:3:0","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/2020/06/11/hugo-github-action/"},{"categories":["设计模式"],"content":"本文介绍设计模式之模板方法模式","date":"2019-11-09","objectID":"/2019/11/09/design-template/","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"一、前言 Template Pattern 模板方法 来自 Wiki 百科的介绍： 模板方法模型是一种行为设计模型。模板方法是一个定义在父类别的方法，在模板方法中会呼叫多个定义在父类别的其他方法，而这些方法有可能只是抽象方法并没有实作，模板方法仅决定这些抽象方法的执行顺序，这些抽象方法的实作由子类别负责，并且子类别不允许覆写模板方法。 模板方法是属于设计模式的行为型模式 模板方法模式按照我的白话文理解： 首先定一个“抽象类”，它有一个模板方法A，定义可能需要子类实现的方法B，C，D…，然后在A方法里面编排好了B，C，D等的位置，当实现类调用A的时候，会调用各自实现的B，C，D方法（某些方法有默认实现，子类可以不实现），从而在一样的大流程里面进行不一样的操作。 ","date":"2019-11-09","objectID":"/2019/11/09/design-template/:1:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"二、简单实例 故事背景 阳光明媚的一天，玩码部落来了一群腿长一米八的MM，它们来自台湾，杭州及北京，她们将介绍各自家乡是如何准备丰富的晚餐的。 ","date":"2019-11-09","objectID":"/2019/11/09/design-template/:2:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"2.1 Java版本 2.1.1 定义接口 public interface Dinner { /** * 晚餐 */ void doDinner(); } 定义一个接口，就一个无参的 void 方法。 2.1.2 定义抽象方法 public abstract class AbstractDinner implements Dinner { protected String name; public AbstractDinner(String name) { this.name = name; } private void eat() { System.out.printf(\"%sMM说：开吃喽\", name).println(); } protected boolean foodEnough() { return true; } protected void doShopping() { System.out.println(\"门口小贩买菜\"); } protected abstract void beforeCooking(); protected abstract String doCooking(); protected abstract void afterCooking(); @Override public void doDinner() { if (!foodEnough()) { doShopping(); } beforeCooking(); System.out.println(doCooking()); afterCooking(); eat(); } } 定义 AbstractDinner 实现接口，它自身有五个方法，默认实现的 foodEnough 和 doShopping，以及抽象方法 beforeCooking、doCooking 和 afterCooking。 doDinner 编排了这些方法的流程或者说定义了各阶段的步骤。 2.1.3 定义实现类 public class BeijingDinner extends AbstractDinner { public BeijingDinner(String name) { super(name); } @Override protected void beforeCooking() { System.out.printf(\"%sMM 在洗菜切菜\", name).println(); } @Override protected String doCooking() { return name + \"MM 在做\" + name + \"菜\"; } @Override protected void afterCooking() { System.out.printf(\"%sMM 让你去品尝\", name).println(); } } public class TaiwanDinner extends AbstractDinner { public TaiwanDinner(String name) { super(name); } @Override protected boolean foodEnough() { // 每次都买食物 return false; } @Override protected void doShopping() { System.out.println(\"生鲜超市购买，一定要买茶叶蛋\"); } @Override protected void beforeCooking() { System.out.printf(\"%sMM 在洗菜切菜\", name).println(); } @Override protected String doCooking() { return name + \"MM 在做\" + name + \"菜\"; } @Override protected void afterCooking() { System.out.printf(\"%sMM 让你去品尝\", name).println(); } } public class HangzhouDinner extends AbstractDinner { public HangzhouDinner(String name) { super(name); } @Override protected boolean foodEnough() { // 每次都买食物 return false; } @Override protected void beforeCooking() { System.out.printf(\"%sMM 在洗菜切菜\", name).println(); } @Override protected String doCooking() { return name + \"MM 在做\" + name + \"菜\"; } @Override protected void afterCooking() { System.out.printf(\"%sMM 让你去品尝\", name).println(); } } 定义了三个实现类，都实现了3个抽象方法。另外 TaiwanDinner 重写了另外两个方法，HangzhouDinner 只重写了 foodEnough。 2.1.4 运行例子 代码： public class DinnerDemo { public static void main(String[] args) { System.out.println(\"---准备台湾餐---\"); Dinner dinner1 = new TaiwanDinner(); dinner1.doDinner(); System.out.println(\"---准备杭州餐---\"); Dinner dinner2 = new HangzhouDinner(); dinner2.doDinner(); System.out.println(\"---准备北京餐---\"); Dinner dinner3 = new BeijingDinner(); dinner3.doDinner(); } } 输出结果： ---准备台湾餐--- 生鲜超市购买，一定要买茶叶蛋 台湾MM 在洗菜切菜 台湾MM 在做台湾菜 台湾MM 让你去品尝 台湾MM说：开吃喽 ---准备杭州餐--- 门口小贩买菜 杭州MM 在洗菜切菜 杭州MM 在做杭州菜 杭州MM 让你去品尝 杭州MM说：开吃喽 ---准备北京餐--- 北京MM 在洗菜切菜 北京MM 在做北京菜 北京MM 让你去品尝 北京MM说：开吃喽 ","date":"2019-11-09","objectID":"/2019/11/09/design-template/:2:1","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"2.2 Golang 版本 声明下：在 golang 中，由于不存在抽象类和真正的继承，所以只能通过一个基础类来充当抽象类，子类通过组合基础类来实现通用方法的继承。 2.2.1 定义接口 type Dinner interface { DoDinner() } 2.2.2 定义抽象类 type AbstractCooking struct { foodEnough func() bool doShopping func() beforeCooking func() doCooking func() string afterCooking func() Name string } func (d *AbstractCooking) DoDinner() { if !d.foodEnough() { d.doShopping() } d.beforeCooking() fmt.Println(d.doCooking()) d.afterCooking() d.eat() } func (d *AbstractCooking) eat() { fmt.Println(fmt.Sprintf(\"%sMM说：开吃喽\", d.Name)) } 这里和 Java 不一样的地方是 go 的结构体可以拥有 func() 属性（也可以拥有接口属性）。 实现 Dinner 的方法 DoDinner , 编排了一系列的方法。 2.2.3 定义实现类 type HZDinner struct { AbstractCooking } func NewHZDinner(name string) *HZDinner { c := new(HZDinner) c.Name = name // 选择实现的 c.AbstractCooking.foodEnough = c.foodEnough c.AbstractCooking.doShopping = doShopping // 必须实现的 c.AbstractCooking.beforeCooking = c.beforeCooking c.AbstractCooking.doCooking = c.doCooking c.AbstractCooking.afterCooking = c.afterCooking return c } func (c *HZDinner) foodEnough() bool { return false } func (c *HZDinner) beforeCooking() { println(fmt.Printf(\"%sMM 在洗菜切菜\", c.Name)) } func (c *HZDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", c.Name, c.Name) } func (c *HZDinner) afterCooking() { println(fmt.Printf(\"%sMM 让你去品尝\", c.Name)) } type TWDinner struct { AbstractCooking } func NewTWDinner(name string) *TWDinner { c := new(TWDinner) c.Name = name // 选择实现的 c.AbstractCooking.foodEnough = c.foodEnough c.AbstractCooking.doShopping = c.doShopping // 必须实现的 c.AbstractCooking.beforeCooking = c.beforeCooking c.AbstractCooking.doCooking = c.doCooking c.AbstractCooking.afterCooking = c.afterCooking return c } func (c *TWDinner) foodEnough() bool { return false } func (c *TWDinner) doShopping() { fmt.Println(\"生鲜超市购买，一定要买茶叶蛋\") } func (c *TWDinner) beforeCooking() { println(fmt.Printf(\"%sMM 在洗菜切菜\", c.Name)) } func (c *TWDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", c.Name, c.Name) } func (c *TWDinner) afterCooking() { println(fmt.Printf(\"%sMM 让你去品尝\", c.Name)) } type BJDinner struct { AbstractCooking } func NewBJDinner(name string) *BJDinner { c := new(BJDinner) c.Name = name // 选择实现的 c.AbstractCooking.foodEnough = foodEnough c.AbstractCooking.doShopping = doShopping // 必须实现的 c.AbstractCooking.beforeCooking = c.beforeCooking c.AbstractCooking.doCooking = c.doCooking c.AbstractCooking.afterCooking = c.afterCooking return c } func (c *BJDinner) beforeCooking() { println(fmt.Printf(\"%sMM 在洗菜切菜\", c.Name)) } func (c *BJDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", c.Name, c.Name) } func (c *BJDinner) afterCooking() { println(fmt.Printf(\"%sMM 让你去品尝\", c.Name)) } 2.2.4 定义默认实现方法 func foodEnough() bool { return true } func doShopping() { fmt.Println(\"门口小贩买菜\") } 为什么有独立的默认方法，因为 struct 里面定义了 foodEnough() bool 和 doShopping() 两个方法，go 里面是不能重名的，因此不能再写属于 AbstractCooking 的方法。 func (d *AbstractCooking) foodEnough() bool { return true } 这个方法如何写了，去掉了 struct 的 foodEnough() bool，那么创建实现类的时候就没办法 c.AbstractCooking.foodEnough = c.foodEnough 进行 func() 赋值，从而 d.foodEnough() 会一直调用 AbstractCooking 下的 foodEnough()，实现类没办法自定义实现了。 2.2.5 运行例子 代码： func TestTemplate1(t *testing.T) { fmt.Println(\"---准备台湾餐---\") d1 := NewTWDinner(\"台湾\") d1.DoDinner() fmt.Println(\"---准备杭州餐---\") d2 := NewHZDinner(\"杭州\") d2.DoDinner() fmt.Println(\"---准备北京餐---\") d3 := NewBJDinner(\"北京\") d3.DoDinner() } 输出结果： ---准备台湾餐--- 生鲜超市购买，一定要买茶叶蛋 台湾MM 在洗菜切菜 台湾MM 在做台湾菜 台湾MM 让你去品尝 台湾MM说：开吃喽 ---准备杭州餐--- 门口小贩买菜 杭州MM 在洗菜切菜 杭州MM 在做杭州菜 杭州MM 让你去品尝 杭州MM说：开吃喽 ---准备北京餐--- 北京MM 在洗菜切菜 北京MM 在做北京菜 北京MM 让你去品尝 北京MM说：开吃喽 ","date":"2019-11-09","objectID":"/2019/11/09/design-template/:2:2","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"2.3 Golang版本2 上面例子是在 struct 中定义，相当于是抽象方法的意思，而这版本把那部分方法都定义到了接口。 2.3.1 定义接口 type Dinner2 interface { foodEnough() bool doShopping() beforeCooking() doCooking() string afterCooking() } 2.3.2 定义抽象类 type AbstractDinner struct { } func (AbstractDinner) foodEnough() bool { return true } func (AbstractDinner) doShopping() { fmt.Println(\"门口小贩买菜\") } func (AbstractDinner) beforeCooking() { } func (AbstractDinner) doCooking() string { return \"\" } func (AbstractDinner) afterCooking() { } 实现 Dinner2 接口，和下面等价 type AbstractDinner struct { Dinner2 } func (AbstractDinner) foodEnough() bool { return true } func (AbstractDinner) doShopping() { fmt.Println(\"门口小贩买菜\") } 2.3.3 定义实现类 type HangzhouDinner struct { AbstractDinner } func NewHangzhouDinner(name string) Dinner2 { return \u0026HangzhouDinner{ AbstractDinner{ Name: name, }, } } func (d *HangzhouDinner) foodEnough() bool { return false } func (d *HangzhouDinner) beforeCooking() { fmt.Println(fmt.Sprintf(\"%sMM 在洗菜切菜\", d.Name)) } func (d *HangzhouDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", d.Name, d.Name) } func (d *HangzhouDinner) afterCooking() { fmt.Println(fmt.Sprintf(\"%sMM 让你去品尝\", d.Name)) } type BeijingDinner struct { AbstractDinner } func NewBeijingDinner(name string) Dinner2 { return \u0026BeijingDinner{ AbstractDinner{ Name: name, }, } } func (d *BeijingDinner) beforeCooking() { fmt.Println(fmt.Sprintf(\"%sMM 在洗菜切菜\", d.Name)) } func (d *BeijingDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", d.Name, d.Name) } func (d *BeijingDinner) afterCooking() { fmt.Println(fmt.Sprintf(\"%sMM 让你去品尝\", d.Name)) } type TaiwanDinner struct { AbstractDinner } func NewTaiwanDinner(name string) Dinner2 { return \u0026TaiwanDinner{ AbstractDinner{ Name: name, }, } } func (d *TaiwanDinner) foodEnough() bool { return false } func (d *TaiwanDinner) doShopping() { fmt.Println(\"生鲜超市购买，一定要买茶叶蛋\") } func (d *TaiwanDinner) beforeCooking() { fmt.Println(fmt.Sprintf(\"%sMM 在洗菜切菜\", d.Name)) } func (d *TaiwanDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", d.Name, d.Name) } func (d *TaiwanDinner) afterCooking() { fmt.Println(fmt.Sprintf(\"%sMM 让你去品尝\", d.Name)) } 2.3.4 定义模板方法 func DoDinner(d Dinner2) { if !d.foodEnough() { d.doShopping() } d.beforeCooking() fmt.Println(d.doCooking()) d.afterCooking() d.eat() } func (ad AbstractDinner) eat() { fmt.Println(fmt.Sprintf(\"%sMM说：开吃喽\", ad.Name)) } 如果想把抽象方法放到结构体上，也可以如下： type Dinner2 interface { ... DoDinner(d Dinner2) } func (ad AbstractDinner) DoDinner(d Dinner2) { if !d.foodEnough() { d.doShopping() } d.beforeCooking() fmt.Println(d.doCooking()) d.afterCooking() ad.eat() } func (ad AbstractDinner) eat() { fmt.Println(fmt.Sprintf(\"%sMM说：开吃喽\", ad.Name)) } 到时候调用的话就 DoDinner 改成 d1 := NewTaiwanDinner(\"台湾\") d1.DoDinner(d1)。 2.3.5 运行例子 代码： func TestTemplate2(t *testing.T) { fmt.Println(\"---准备台湾餐---\") d1 := NewTaiwanDinner(\"台湾\") DoDinner(d1) fmt.Println(\"---准备杭州餐---\") d2 := NewHangzhouDinner(\"杭州\") DoDinner(d2) fmt.Println(\"---准备北京餐---\") d3 := NewTaiwanDinner(\"北京\") DoDinner(d3) } 输出结果： ---准备台湾餐--- 生鲜超市购买，一定要买茶叶蛋 台湾MM 在洗菜切菜 台湾MM 在做台湾菜 台湾MM 让你去品尝 台湾MM说：开吃喽 ---准备杭州餐--- 门口小贩买菜 杭州MM 在洗菜切菜 杭州MM 在做杭州菜 杭州MM 让你去品尝 杭州MM说：开吃喽 ---准备北京餐--- 生鲜超市购买，一定要买茶叶蛋 北京MM 在洗菜切菜 北京MM 在做北京菜 北京MM 让你去品尝 北京MM说：开吃喽 ","date":"2019-11-09","objectID":"/2019/11/09/design-template/:2:3","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"2.4、例子说明 ","date":"2019-11-09","objectID":"/2019/11/09/design-template/:2:4","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"三、开源框架使用场景 列举某几个框架，供大家参考 ","date":"2019-11-09","objectID":"/2019/11/09/design-template/:3:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"3.1 JDK AbstractList public abstract class AbstractList\u003cE\u003e extends AbstractCollection\u003cE\u003e implements List\u003cE\u003e { ... public void add(int index, E element) { throw new UnsupportedOperationException(); } ... public boolean addAll(int index, Collection\u003c? extends E\u003e c) { rangeCheckForAdd(index); boolean modified = false; for (E e : c) { add(index++, e); modified = true; } return modified; } ... } 实现类实现 add 的逻辑，如： public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable { // ... public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } // ... } ","date":"2019-11-09","objectID":"/2019/11/09/design-template/:3:1","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"3.1 spring 中的 事务管理器 public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable { // ... public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException { Object transaction = doGetTransaction(); // Cache debug flag to avoid repeated checks. boolean debugEnabled = logger.isDebugEnabled(); if (definition == null) { // Use defaults if no transaction definition given. definition = new DefaultTransactionDefinition(); } if (isExistingTransaction(transaction)) { // Existing transaction found -\u003e check propagation behavior to find out how to behave. return handleExistingTransaction(definition, transaction, debugEnabled); } // Check definition settings for new transaction. if (definition.getTimeout() \u003c TransactionDefinition.TIMEOUT_DEFAULT) { throw new InvalidTimeoutException(\"Invalid transaction timeout\", definition.getTimeout()); } // No existing transaction found -\u003e check propagation behavior to find out how to proceed. if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) { throw new IllegalTransactionStateException( \"No existing transaction found for transaction marked with propagation 'mandatory'\"); } else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED || definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW || definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) { SuspendedResourcesHolder suspendedResources = suspend(null); if (debugEnabled) { logger.debug(\"Creating new transaction with name [\" + definition.getName() + \"]: \" + definition); } try { boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); doBegin(transaction, definition); prepareSynchronization(status, definition); return status; } catch (RuntimeException ex) { resume(null, suspendedResources); throw ex; } catch (Error err) { resume(null, suspendedResources); throw err; } } else { // Create \"empty\" transaction: no actual transaction, but potentially synchronization. if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT \u0026\u0026 logger.isWarnEnabled()) { logger.warn(\"Custom isolation level specified but no actual transaction initiated; \" + \"isolation level will effectively be ignored: \" + definition); } boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS); return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null); } } // ... protected abstract void doBegin(Object transaction, TransactionDefinition definition) throws TransactionException; ... } 这里只拿 getTransaction 和 doBegin 举例，非常标准的写法 getTransaction 还用了 final 描述，表示子类不允许改变。 当我自定义事务管理器的时候，比如每次事务开启创建一个 traceId，效果如下： public class GongDaoDataSourceTransactionManager extends DataSourceTransactionManager implements ResourceTransactionManager, InitializingBean, EnvironmentAware { // ... protected void doBegin(Object transaction, TransactionDefinition definition) { String currentXid; if (XIDContext.getCurrent() != null \u0026\u0026 null != XIDContext.getCurrent().getId()) { currentXid = xidGenerator.getXID(); XIDContext.childCurrent(new TransactionContent(currentXid, definition.getName())); } else { currentXid = xidGenerator.getXID(); XIDContext.setXid(new TransactionContent(currentXid, definition.getName())); } if (null == HyjalTransactionFileAppender.contextHolder.get()) { String logFileName = HyjalTransactionFileAppender.makeLogFileName(new Date(), HyjalTransactionFileAppender.logId.get()); HyjalTransactionFileAppender.contextHolder.set(logFileName); } try { if (null == XIDContext.getCurrentXid()) { XIDContext.setXid(xidGenerator.getXID()); } super.doBegin(transaction, definition); } finally { if (logger.isDebugEnabled()) { logger.debug(\"do begin Xi","date":"2019-11-09","objectID":"/2019/11/09/design-template/:3:2","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"四、优势和劣势 ","date":"2019-11-09","objectID":"/2019/11/09/design-template/:4:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"4.1 优势 对扩展开放，对修改关闭，符合“开闭原则” 定义标准算法，子类可自定义扩展，把变性和不变性分离 子类的扩展不会导致标准算法结构 能够提高代码复用，公共部分易维护 ","date":"2019-11-09","objectID":"/2019/11/09/design-template/:4:1","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"4.2 劣势 每一个实现类都需要定义自己的行为，如果复杂业务实现类会膨胀的比较多 ","date":"2019-11-09","objectID":"/2019/11/09/design-template/:4:2","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"五、参考 https://www.tutorialspoint.com/design_pattern/template_pattern.htm https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95 ","date":"2019-11-09","objectID":"/2019/11/09/design-template/:5:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/2019/11/09/design-template/"}]