[{"categories":["go源码"],"content":"一、前言 相信很多java程序员都背过或者用过StringBuilder或者StringBuffer这种sb代码。 最近工作需要查看Helm的源码的时候，注意到一个特别使用的字符串连接的方法strings.Builder，咋一看特别像java的StringBuilder，所以研究了下它，以及了解了下其他连接字符串的方法，结果发现确实strings.Builder的效果显著。 ","date":"2021-06-21","objectID":"/zh-cn/2021/06/21/go-sourcecode-string-builder/:1:0","tags":["golang","源码","builder"],"title":"了解一下Go中的\"sb\"代码？","uri":"/zh-cn/2021/06/21/go-sourcecode-string-builder/"},{"categories":["go源码"],"content":"二、内容 ","date":"2021-06-21","objectID":"/zh-cn/2021/06/21/go-sourcecode-string-builder/:2:0","tags":["golang","源码","builder"],"title":"了解一下Go中的\"sb\"代码？","uri":"/zh-cn/2021/06/21/go-sourcecode-string-builder/"},{"categories":["go源码"],"content":"1.首先我放出我了解的几个方法，并给出在我本地电脑跑benchmark的效果，点击查看代码： ①.传统的+号连接 func BenchmarkTestStrPlus(b *testing.B) { var result string b.ResetTimer() for i := 0; i \u003c b.N; i++ { result = strconv.Itoa(i) + result } } ②.fmt.Sprintf连接 func BenchmarkTestStrSprintf(b *testing.B) { var result string b.ResetTimer() for i := 0; i \u003c b.N; i++ { result = fmt.Sprintf(\"%s%s\", result, strconv.Itoa(i)) } } ③. strings.Join连接 func BenchmarkTestJoin(b *testing.B) { var result string b.ResetTimer() for i := 0; i \u003c b.N; i++ { result = strings.Join([]string{result, strconv.Itoa(i)}, \"\") } } ④.bytes.Buffer连接 func BenchmarkTestBuffer(b *testing.B) { var result bytes.Buffer b.ResetTimer() for i := 0; i \u003c b.N; i++ { if _, err := result.WriteString(strconv.Itoa(i)); err != nil { panic(err) } } } ⑤.最后就是strings.Builder方法连接 func BenchmarkTestBuilder(b *testing.B) { var result strings.Builder b.ResetTimer() for i := 0; i \u003c b.N; i++ { result.WriteString(strconv.Itoa(i)) } } 以上就是我了解到的5种字符串拼接的方法，大家可以猜测下他们的效率顺序，大家如果谁对我这种测试方法质疑的，可以留言讨论。csdn链接:https://blog.csdn.net/u010927340/article/details/118120669 我觉得第二种性能应该最差，毕竟它支持的各种类型太多，一般来说兼容性是以性能降低的代价。其次就是第一钟，最原始的拼接的字符串的方式，为什么呢？这个和java的String很像，都是immutable，换言之就是当更改这个string对象的时候，其实并没有更改该string，而是新增了一个string，但是给人的感觉好像把它修改了，为什么这么设计，大家可以自行百度，但是该设计会导致在拼接字符串的时候会产生大量的string，不仅耗时，还耗内存，更有甚者导致STW。然后我觉得会是第三种，点开看了下他的Join方法，竟然里面使用了strings.Builder，可惜他是直接返回了string，相当于每个Join操作也产生了新的string，所以我把她放到第三位。最后就是第4和第5的PK，还是我上面提到的判断思路：谁更专业肯定效率最好。所以我觉得第5种性能还是要比第4种好。 到此我的运行前的性能判断，从高到低如下: 5 \u003c 4 \u003c 3 \u003c 1 \u003c 2 好的用我的渣渣电脑运行，结果如下（事实上我运行了很多次，性能指标大小顺序都是一致的）： cpu: Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz BenchmarkTestStrPlus BenchmarkTestStrPlus-4 187838 226381 ns/op BenchmarkTestStrSprintf BenchmarkTestStrSprintf-4 130268 306116 ns/op BenchmarkTestJoin BenchmarkTestJoin-4 182164 289074 ns/op BenchmarkTestBuffer BenchmarkTestBuffer-4 20228474 107.1 ns/op BenchmarkTestBuilder BenchmarkTestBuilder-4 10084845 99.34 ns/op 事实上的性能从高到低的结果如下: 5 \u003c 4 \u003c 1 \u003c 3 \u003c 2 大型翻车现场，原来原始的方式竟然没想象中那么差，string的原始拼接在很多语言中都分别在编译期和运行时都有特地优化过，毕竟它的使用频率非常高，优化它就相当于优化了整个语言。这个估计能查资料才能找到具体原因，在这里我不关心到底为什么性能比3还强，我这里只聚焦于strings.Builder，因为从宏观上来说他肯定比除第4种方法外都强，在这里也不额外关心为什么bytes.Buffer以微弱的劣势输于strings.Builder，事实上我发现strings.Builder的实现和bytes.Buffer的原理很像，都是操作byte数组，但是bytes.Buffer的功能更强。我关心的是这个结论很重要。下面我们一起领略下strings.Builder的设计吧。 ","date":"2021-06-21","objectID":"/zh-cn/2021/06/21/go-sourcecode-string-builder/:2:1","tags":["golang","源码","builder"],"title":"了解一下Go中的\"sb\"代码？","uri":"/zh-cn/2021/06/21/go-sourcecode-string-builder/"},{"categories":["go源码"],"content":"2.strings.Builder的源码很简单，加上注释也才100多行 我给大家列一下核心代码，那就更少了 // A Builder is used to efficiently build a string using Write methods. // It minimizes memory copying. The zero value is ready to use. // Do not copy a non-zero Builder. type Builder struct { addr *Builder // of receiver, to detect copies by value buf []byte } func (b *Builder) copyCheck() { if b.addr == nil { b.addr = (*Builder)(noescape(unsafe.Pointer(b))) } else if b.addr != b { panic(\"strings: illegal use of non-zero Builder copied by value\") } } func (b *Builder) String() string { return *(*string)(unsafe.Pointer(\u0026b.buf)) } // grow copies the buffer to a new, larger buffer so that there are at least n bytes of capacity beyond len(b.buf). func (b *Builder) grow(n int) { buf := make([]byte, len(b.buf), 2*cap(b.buf)+n) copy(buf, b.buf) b.buf = buf } // Grow grows b's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to b without another allocation. If n is negative, Grow panics. func (b *Builder) Grow(n int) { b.copyCheck() if n \u003c 0 { panic(\"strings.Builder.Grow: negative count\") } if cap(b.buf)-len(b.buf) \u003c n { b.grow(n) } } func (b *Builder) Write(p []byte) (int, error) { b.copyCheck() b.buf = append(b.buf, p...) return len(p), nil } func (b *Builder) WriteByte(c byte) error { b.copyCheck() b.buf = append(b.buf, c) return nil } func (b *Builder) WriteRune(r rune) (int, error) { b.copyCheck() if r \u003c utf8.RuneSelf { b.buf = append(b.buf, byte(r)) return 1, nil } l := len(b.buf) if cap(b.buf)-l \u003c utf8.UTFMax { b.grow(utf8.UTFMax) } n := utf8.EncodeRune(b.buf[l:l+utf8.UTFMax], r) b.buf = b.buf[:l+n] return n, nil } func (b *Builder) WriteString(s string) (int, error) { b.copyCheck() b.buf = append(b.buf, s...) return len(s), nil } // Reset resets the Builder to be empty. func (b *Builder) Reset() { b.addr = nil b.buf = nil } 首先实现了io包中的Writer``StringWriter``ByteWriter接口，也就是说在其他地方接受这3个接口的地方都能用strings.Builder替代写入。 开头1~4行的注释就申明了Builder的设计宗旨：尽可能避免内存拷贝，而且还特地提醒了：Builder不能被拷贝。为什么不能被拷贝呢？Builder的设计宗旨就是避免内存拷贝，但是如果说再拷贝Builder的话就违背了。 为了做到上面2点，Builder的结构体就体现了: type Builder struct { addr *Builder // of receiver, to detect copies by value buf []byte } 里面包括一个字节数组，在go中string底层其实就是字节数组，为什么这里也用了数组呢？底层字节数组方便往数组里面塞东西，自己可以控制扩容，扩多少。这样不会像string的原始拼接方式那样产生大量的string对象。还有1个指向自己的Builder指针，正如注释所说：检测是否有拷贝了整个Builder对象。如果拷贝了会怎样呢？见copyCheck代码： func (b *Builder) copyCheck() { if b.addr == nil { // This hack works around a failing of Go's escape analysis // that was causing b to escape and be heap allocated. // See issue 23382. // TODO: once issue 7921 is fixed, this should be reverted to // just \"b.addr = b\". b.addr = (*Builder)(noescape(unsafe.Pointer(b))) } else if b.addr != b { panic(\"strings: illegal use of non-zero Builder copied by value\") } } 会直接发生panic，很霸道，直接被Builder拒绝了。 接下来我写一个拷贝Builder的代码验证下，代码链接https://play.studygolang.com/p/bDt9lGImCiy： var sb strings.Builder sb.WriteString(\"1\") var sb_copy = *(*strings.Builder)(unsafe.Pointer(\u0026sb)) sb_copy.WriteString(\"2\") 如下为panic的输出: panic: strings: illegal use of non-zero Builder copied by value goroutine 1 [running]: strings.(*Builder).copyCheck(...) /usr/local/go-faketime/src/strings/builder.go:42 strings.(*Builder).WriteString(...) /usr/local/go-faketime/src/strings/builder.go:122 main.main() /tmp/sandbox194128443/prog.go:12 +0x1ad 所有Write*操作都有copyCheck的拷贝检测，如果有发生类似的拷贝，都会panic。但是它强调了Builder的重用功能，需要Reset之后才能构造下一个String。 接下来要说明的是Grow方法，该方法是提供的一个public的方法用来给Builder扩容buf的数组。为什么要提供这个呢？可以看到除了WriteRune必要的时候主动扩容了，其他Write*方法并没有去事先判断扩容的-依赖切片的自动判断扩容。其实Builder提供这个Grow方法是给使用者使用，提前能判断好长度，然后扩容，这样后期调用Write*方法就没有内存拷贝的操作，因为一旦发生扩容的话就会有2个问题：分配内存和拷贝。 代码34行判断如果buf数组的剩余容量小于需要扩容的长度，那么才去调用私有的grow去扩容: // grow copies the buffer to a new, larger buffer so that there are at least n // bytes of capacity beyond len(b.buf). func (b *Builder) grow(n int) { buf := make([]byte, len(b.buf), 2*cap(b.buf)+n) copy(buf, b.buf) b.buf = buf } 这几行代码很清晰，就是分配内存，容量是以前的容量再加上需要扩容的数量，这样就确保长度n的字节能存到Builder去。 接下来看看WriteRune方法，因为其他的Write*方法太简单，就略","date":"2021-06-21","objectID":"/zh-cn/2021/06/21/go-sourcecode-string-builder/:2:2","tags":["golang","源码","builder"],"title":"了解一下Go中的\"sb\"代码？","uri":"/zh-cn/2021/06/21/go-sourcecode-string-builder/"},{"categories":["go源码"],"content":"三、总结 上面分析了strings.Builder的源码，知道了拼接字符串的底层逻辑，所以如果有大量的string对象需要拼接，那么strings.Builder非常合适，而且最好知道所有要拼接的string的长度总和，事先分配好内存，还能进一步提高效率。 而且我发现其实Reset方法还可以优化的角度，不用把b.buf设为nil，这样的话以前申请的buf的数组就会被回收掉，我觉得可以利用起来，不用下次拼接字符串的时候再申请内存。不知道你怎么看这个问题呢？ 我的微信公众号: ","date":"2021-06-21","objectID":"/zh-cn/2021/06/21/go-sourcecode-string-builder/:3:0","tags":["golang","源码","builder"],"title":"了解一下Go中的\"sb\"代码？","uri":"/zh-cn/2021/06/21/go-sourcecode-string-builder/"},{"categories":["名库"],"content":"uitable is a go library for representing data as tables for terminal applications. It provides primitives for sizing and wrapping columns to improve readability.","date":"2021-05-16","objectID":"/zh-cn/2021/05/16/go-package-uitable/","tags":["名库"],"title":"Go名库欣赏-uitable：终端数据表格展示工具","uri":"/zh-cn/2021/05/16/go-package-uitable/"},{"categories":["名库"],"content":"一、前言 最近发现go用作一个运维工具是真的很好用，我觉得比python好用多了，python的依赖太麻烦了，而go作为运维工具可以直接打包成二进制包，可移植性极好，而且go天生对linux亲和性极强。像k8s的一个强大的运维命令-kubectl，打印的数据都是以表格的形式展示，表达能力很强，像实现这种终端表格展示有一个好用的工具-uitable ","date":"2021-05-16","objectID":"/zh-cn/2021/05/16/go-package-uitable/:1:0","tags":["名库"],"title":"Go名库欣赏-uitable：终端数据表格展示工具","uri":"/zh-cn/2021/05/16/go-package-uitable/"},{"categories":["名库"],"content":"二、内容 这是我用kubectl get pods打印的一个终端界面： NAME READY STATUS RESTARTS AGE nginx1-0 1/1 Running 0 11d nginx2-0 1/1 Running 0 11d 那么用该该库怎么实现呢？ type pod struct { NAME, READY, STATUS, AGE string RESTARTS int } var pods = []pod{ {\"nginx1-0 \", \"1/1\", \"Running\", \"11d\", 0}, {\"nginx2-0\", \"1/1\", \"Running\", \"11d\", 0}, } func main() { table := uitable.New() table.MaxColWidth = 50 table.AddRow(\"NAME\", \"READY\", \"STATUS\", \"RESTARTS\", \"AGE\") for _, pod := range pods { table.AddRow(pod.NAME, pod.READY, pod.STATUS, pod.AGE, pod.RESTARTS) } fmt.Println(table) } 执行代码的结果如下: NAME READY STATUS RESTARTS AGE nginx1-0 1/1 Running 11d 0 nginx2-0 1/1 Running 11d 0 可以发现基本和k8s的输出一模一样。到这里或许有人会说：就这？ 下面给大家展示另外一个功能：改变字体颜色输出。如果你的工具用上这么一个功能，还不能显示出你的逼格吗？当然这里会使用到另外一个库，配合使用才行github.com/fatih/color。 修改如下代码： type pod struct { NAME, READY, STATUS, AGE string RESTARTS int } var pods = []pod{ {\"nginx1-0 \", \"1/1\", \"Running\", \"11d\", 0}, {\"nginx2-0\", \"1/1\", \"Running\", \"11d\", 0}, } func main() { table := uitable.New() table.MaxColWidth = 100 table.RightAlign(10) table.AddRow(\"NAME\", \"READY\", \"STATUS\", \"RESTARTS\", \"AGE\") for _, pod := range pods { table.AddRow(color.RedString(pod.NAME), color.WhiteString(pod.READY), color.BlueString(pod.STATUS), color.GreenString(pod.AGE), color.YellowString(\"%d\", pod.RESTARTS)) } fmt.Println(table) } 打印的效果如下： ","date":"2021-05-16","objectID":"/zh-cn/2021/05/16/go-package-uitable/:2:0","tags":["名库"],"title":"Go名库欣赏-uitable：终端数据表格展示工具","uri":"/zh-cn/2021/05/16/go-package-uitable/"},{"categories":["名库"],"content":"三、总结 经测试，该包可以在mac，linux和windows上都能使用，包括上面演示的不同颜色的字体的包也能跨平台使用。 我的微信公众号: ","date":"2021-05-16","objectID":"/zh-cn/2021/05/16/go-package-uitable/:3:0","tags":["名库"],"title":"Go名库欣赏-uitable：终端数据表格展示工具","uri":"/zh-cn/2021/05/16/go-package-uitable/"},{"categories":["k8s","go","工作问题"],"content":"一、前言 今天在排查一个线上的中间件集群，该中间件集群是通过 helm 部署到k8s集群当中，有一个statefulset总是有一个pod还没有ready，故想去看看为啥一直不正常。在k8s当中关联对象之间的关系，我想当然的使用statefulset的label selector去找，结果却找到了其他类似statefulset所调度的pod。问了一些人，有说使用selector都能找到，众所周知，在k8s的很多描述文件中都是使用label相互之间关联，但是为啥这次不行了呢？有说直接使用名称匹配即可，感觉不适合靠谱。具体怎么找呢？ ","date":"2021-03-13","objectID":"/zh-cn/2021/03/13/k8s-find-pods-of-statefulset/:1:0","tags":["k8s","statefulset"],"title":"怒喷k8s:竟然还要这么才能正确找到statefulset的pods","uri":"/zh-cn/2021/03/13/k8s-find-pods-of-statefulset/"},{"categories":["k8s","go","工作问题"],"content":"二、问题复现 我的statefulest描述文件-nginx1.yaml: apiVersion:v1kind:Servicemetadata:name:nginx1labels:app:nginxspec:ports:- port:80clusterIP:Noneselector:app:nginx---apiVersion:apps/v1kind:StatefulSetmetadata:name:nginx1spec:serviceName:\"nginx1\"selector:matchLabels:app:nginxtemplate:metadata:labels:app:nginxspec:containers:- name:nginximage:nginxports:- containerPort:80 第二个statefulest描述文件-nginx2.yaml: apiVersion:v1kind:Servicemetadata:name:nginx2labels:app:nginxspec:ports:- port:80clusterIP:Noneselector:app:nginx---apiVersion:apps/v1kind:StatefulSetmetadata:name:nginx2spec:serviceName:\"nginx2\"selector:matchLabels:app:nginxtemplate:metadata:labels:app:nginxspec:containers:- name:nginximage:nginxports:- containerPort:80 可以看到2个statefulset的selector都是app: nginx. 执行kubectl get sts: NAME READY AGE nginx1 1/1 5m16s nginx2 1/1 2m19s 执行kubectl get pods: NAME READY STATUS RESTARTS AGE nginx1-0 1/1 Running 0 6m24s nginx2-0 1/1 Running 0 3m27s 发现statefulset已经正常起来了。 此时发现使用label的selector已经不能正常得到statefulset所管理的pod，执行kubectl get pods -l app=nginx结果如下： NAME READY STATUS RESTARTS AGE nginx1-0 1/1 Running 0 9m30s nginx2-0 1/1 Running 0 6m33s 所以怎么才能正确得到statefulset的pod呢？ ","date":"2021-03-13","objectID":"/zh-cn/2021/03/13/k8s-find-pods-of-statefulset/:2:0","tags":["k8s","statefulset"],"title":"怒喷k8s:竟然还要这么才能正确找到statefulset的pods","uri":"/zh-cn/2021/03/13/k8s-find-pods-of-statefulset/"},{"categories":["k8s","go","工作问题"],"content":"源码解析 源码根据kubernets源码v1.20.2版本。 可以大概猜到代码应该在pkg下的statefulest的controller，定位到pkg/controller/statefulset/stateful_set.go,稍稍搜索该代码会发现第一处代码： // getPodsForStatefulSet returns the Pods that a given StatefulSet should manage. // It also reconciles ControllerRef by adopting/orphaning. // // NOTE: Returned Pods are pointers to objects from the cache. // If you need to modify one, you need to copy it first. func (ssc *StatefulSetController) getPodsForStatefulSet(set *apps.StatefulSet, selector labels.Selector) ([]*v1.Pod, error) { // List all pods to include the pods that don't match the selector anymore but // has a ControllerRef pointing to this StatefulSet. pods, err := ssc.podLister.Pods(set.Namespace).List(labels.Everything()) if err != nil { return nil, err } filter := func(pod *v1.Pod) bool { // Only claim if it matches our StatefulSet name. Otherwise release/ignore. return isMemberOf(set, pod) } cm := controller.NewPodControllerRefManager(ssc.podControl, set, selector, controllerKind, ssc.canAdoptFunc(set)) return cm.ClaimPods(pods, filter) } 该处代码是获取pod被哪些statefulset所管理，上面我的2个statefulset都是被selector``app: nginx搜管理，所以根据nginx1-0和nginx2-0任一都会找到2个satefulst：nginx1和nginx2。 第二处代码是根据statefulset找到所管理的pod: // getPodsForStatefulSet returns the Pods that a given StatefulSet should manage. // It also reconciles ControllerRef by adopting/orphaning. // // NOTE: Returned Pods are pointers to objects from the cache. // If you need to modify one, you need to copy it first. func (ssc *StatefulSetController) getPodsForStatefulSet(set *apps.StatefulSet, selector labels.Selector) ([]*v1.Pod, error) { // List all pods to include the pods that don't match the selector anymore but // has a ControllerRef pointing to this StatefulSet. pods, err := ssc.podLister.Pods(set.Namespace).List(labels.Everything()) if err != nil { return nil, err } filter := func(pod *v1.Pod) bool { // Only claim if it matches our StatefulSet name. Otherwise release/ignore. return isMemberOf(set, pod) } cm := controller.NewPodControllerRefManager(ssc.podControl, set, selector, controllerKind, ssc.canAdoptFunc(set)) return cm.ClaimPods(pods, filter) } 此时注意2处代码filter和ClaimPods方法。先看filter方法逻辑isMemberOf，该方法就会过滤找出statefulset所管理的pod列表。 // isMemberOf tests if pod is a member of set. func isMemberOf(set *apps.StatefulSet, pod *v1.Pod) bool { return getParentName(pod) == set.Name } 明显该代码是匹配了statefulset的名字 // statefulPodRegex is a regular expression that extracts the parent StatefulSet and ordinal from the Name of a Pod var statefulPodRegex = regexp.MustCompile(\"(.*)-([0-9]+)$\") // getParentNameAndOrdinal gets the name of pod's parent StatefulSet and pod's ordinal as extracted from its Name. If // the Pod was not created by a StatefulSet, its parent is considered to be empty string, and its ordinal is considered // to be -1. func getParentNameAndOrdinal(pod *v1.Pod) (string, int) { parent := \"\" ordinal := -1 subMatches := statefulPodRegex.FindStringSubmatch(pod.Name) if len(subMatches) \u003c 3 { return parent, ordinal } parent = subMatches[1] if i, err := strconv.ParseInt(subMatches[2], 10, 32); err == nil { ordinal = int(i) } return parent, ordinal } 正则表达式很明显看出是根据pod的名找到statefulset的名字，这里根据nginx1-0就会找到statefulset``nginx1。 继续回到方法ClaimPods方法： // ClaimPods tries to take ownership of a list of Pods. // // It will reconcile the following: // * Adopt orphans if the selector matches. // * Release owned objects if the selector no longer matches. // // Optional: If one or more filters are specified, a Pod will only be claimed if // all filters return true. // // A non-nil error is returned if some form of reconciliation was attempted and // failed. Usually, controllers should try again later in case reconciliation // is still needed. // // If the error is nil, either the reconciliation succeeded, or no // reconciliation was necessary. The list of Pods that you now own is returned. func (m *PodControllerRefManager) ClaimPods(pods []*v1.Pod, filters ...func(*v1.Pod) bool) ([]*v1.Pod, error) { var claimed []*v1","date":"2021-03-13","objectID":"/zh-cn/2021/03/13/k8s-find-pods-of-statefulset/:2:1","tags":["k8s","statefulset"],"title":"怒喷k8s:竟然还要这么才能正确找到statefulset的pods","uri":"/zh-cn/2021/03/13/k8s-find-pods-of-statefulset/"},{"categories":["k8s","go","工作问题"],"content":"三、总结 在statefulset中既使用了标签匹配，又使用了根据pod的名称截取出来statefulset的名称匹配。所以上面我的示例正确获取方法如下: kubectl get pods -l app=nginx | grep -v NAME | awk '{print $1}' | grep -E --color '^(nginx1)-([0-9]+)$' 结果如下: nginx1-0 ","date":"2021-03-13","objectID":"/zh-cn/2021/03/13/k8s-find-pods-of-statefulset/:3:0","tags":["k8s","statefulset"],"title":"怒喷k8s:竟然还要这么才能正确找到statefulset的pods","uri":"/zh-cn/2021/03/13/k8s-find-pods-of-statefulset/"},{"categories":["数据库"],"content":"本文介绍 canal 的 deployer 模块","date":"2021-01-07","objectID":"/zh-cn/2021/01/07/canal-deployer/","tags":["canal"],"title":"闲聊 canal | deployer 模块","uri":"/zh-cn/2021/01/07/canal-deployer/"},{"categories":["数据库"],"content":"一、前言 canal 有两种使用方式：1、独立部署 2、内嵌到应用中（比如 otter 里面使用 canal）。 deployer模块主要用于独立部署canal server。 ","date":"2021-01-07","objectID":"/zh-cn/2021/01/07/canal-deployer/:1:0","tags":["canal"],"title":"闲聊 canal | deployer 模块","uri":"/zh-cn/2021/01/07/canal-deployer/"},{"categories":["数据库"],"content":"二、基本内容 ","date":"2021-01-07","objectID":"/zh-cn/2021/01/07/canal-deployer/:2:0","tags":["canal"],"title":"闲聊 canal | deployer 模块","uri":"/zh-cn/2021/01/07/canal-deployer/"},{"categories":["数据库"],"content":"2.1 结构 CanalLauncher deployer 源码的切入点，是项目的启动入口。 CanalController 真正执行逻辑的部分，核心。 ","date":"2021-01-07","objectID":"/zh-cn/2021/01/07/canal-deployer/:2:1","tags":["canal"],"title":"闲聊 canal | deployer 模块","uri":"/zh-cn/2021/01/07/canal-deployer/"},{"categories":["数据库"],"content":"2.2 依赖和功能 2.2.1 依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.otter\u003c/groupId\u003e \u003cartifactId\u003ecanal.server\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- 这里指定runtime的metrics provider--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.otter\u003c/groupId\u003e \u003cartifactId\u003ecanal.prometheus\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e 就是对 server 的包装，让它能够稳定的使用 prometheus 是当下和流行的监控体系，后续对接篇幅里面展开。 2.2.2 功能 1、读取canal,properties配置文件 2、启动canal server，监听canal client的请求 3、启动canal instance，连接mysql数据库，伪装成slave，解析binlog 4、在canal的运行过程中，监听配置文件的变化 ","date":"2021-01-07","objectID":"/zh-cn/2021/01/07/canal-deployer/:2:2","tags":["canal"],"title":"闲聊 canal | deployer 模块","uri":"/zh-cn/2021/01/07/canal-deployer/"},{"categories":["数据库"],"content":"三、代码分析 ","date":"2021-01-07","objectID":"/zh-cn/2021/01/07/canal-deployer/:3:0","tags":["canal"],"title":"闲聊 canal | deployer 模块","uri":"/zh-cn/2021/01/07/canal-deployer/"},{"categories":["数据库"],"content":"2.3.1 入口 CanalLauncher 2.3.1.1 代码 public class CanalLauncher { public static void main(String[] args) { try { // ... -- 指定本地配置 String conf = System.getProperty(\"canal.conf\", \"classpath:canal.properties\"); Properties properties = new Properties(); if (conf.startsWith(CLASSPATH_URL_PREFIX)) { conf = StringUtils.substringAfter(conf, CLASSPATH_URL_PREFIX); properties.load(CanalLauncher.class.getClassLoader().getResourceAsStream(conf)); } else { properties.load(new FileInputStream(conf)); } // -- 加载配置文件 final CanalStarter canalStater = new CanalStarter(properties); String managerAddress = CanalController.getProperty(properties, CanalConstants.CANAL_ADMIN_MANAGER); if (StringUtils.isNotEmpty(managerAddress)) { // ... } else { canalStater.setProperties(properties); } canalStater.start(); // -- JVM 钩子 runningLatch.await(); executor.shutdownNow(); // ... } // ... } 2.3.1.2 分析 2.3.1.2.1 指定本地配置 配置文件 canal.properties 可以通过 VM 参数 -Dcanal.conf 去指定自己的名称，比如指定官方提供的 canal_local.properties 2.3.1.2.2 加载配置文件 如果是远程管理的，那么就和远程交互 请求远端地址拉取配置，和本地配置合并 会创建一个定时的线程池拉取 admin 配置上的配置，如果变化了就停止 canalStater，重新设置属性后再启动。 不是远程管理的，那么就把属性设置进去。不过这里 else 下的属性设置是不需要的，重复设置了 2.3.1.2.3 JVM 钩子 当 JVM 关闭会停止 canal，在 com.alibaba.otter.canal.deployer.CanalStarter#start 的 controller.stop() 里面 shutdownThread = new Thread(() -\u003e { try { logger.info(\"## stop the canal server\"); controller.stop(); CanalLauncher.runningLatch.countDown(); } catch (Throwable e) { logger.warn(\"##something goes wrong when stopping canal Server:\", e); } finally { logger.info(\"## canal server is down.\"); } }); Runtime.getRuntime().addShutdownHook(shutdownThread); 通过 CanalStarter 启动，实际上是交给 CanalController 去控制，它是核心，CanalStarter 不再展开。 ","date":"2021-01-07","objectID":"/zh-cn/2021/01/07/canal-deployer/:3:1","tags":["canal"],"title":"闲聊 canal | deployer 模块","uri":"/zh-cn/2021/01/07/canal-deployer/"},{"categories":["数据库"],"content":"2.3.2 核心 CanalController#构造方法 把 CanalLauncher 里面的 properties 加载到了这里 2.3.2.1 整体代码 public CanalController(final Properties properties){ // ... // 初始化全局参数设置 -- 全局配置代码部分详解 globalInstanceConfig = initGlobalConfig(properties); instanceConfigs = new MapMaker().makeMap(); // 初始化instance config initInstanceConfig(properties); // ... // 准备canal server -- 准备Server // ... String canalWithoutNetty = getProperty(properties, CanalConstants.CANAL_WITHOUT_NETTY); if (canalWithoutNetty == null || \"false\".equals(canalWithoutNetty)) { canalServer = CanalServerWithNetty.instance(); canalServer.setIp(ip); canalServer.setPort(port); } // ... -- 借助Zookeeper final String zkServers = getProperty(properties, CanalConstants.CANAL_ZKSERVERS); if (StringUtils.isNotEmpty(zkServers)) { zkclientx = ZkClientx.getZkClient(zkServers); // 初始化系统目录 zkclientx.createPersistent(ZookeeperPathUtils.DESTINATION_ROOT_NODE, true); zkclientx.createPersistent(ZookeeperPathUtils.CANAL_CLUSTER_ROOT_NODE, true); } // -- 监听机制 final ServerRunningData serverData = new ServerRunningData(registerIp + \":\" + port); ServerRunningMonitors.setServerData(serverData); ServerRunningMonitors.setRunningMonitors(MigrateMap.makeComputingMap((Function\u003cString, ServerRunningMonitor\u003e) destination -\u003e { // ... } // 初始化monitor机制 -- 自动扫描机制 autoScan = BooleanUtils.toBoolean(getProperty(properties, CanalConstants.CANAL_AUTO_SCAN)); if (autoScan) { // ... } } 2.3.2.2 全局配置代码 2.3.2.1.1 代码 private InstanceConfig initGlobalConfig(Properties properties) { String adminManagerAddress = getProperty(properties, CanalConstants.CANAL_ADMIN_MANAGER); InstanceConfig globalConfig = new InstanceConfig(); String modeStr = getProperty(properties, CanalConstants.getInstanceModeKey(CanalConstants.GLOBAL_NAME)); if (StringUtils.isNotEmpty(adminManagerAddress)) { // 如果指定了manager地址,则强制适用manager globalConfig.setMode(InstanceMode.MANAGER); } else if (StringUtils.isNotEmpty(modeStr)) { globalConfig.setMode(InstanceMode.valueOf(StringUtils.upperCase(modeStr))); } String lazyStr = getProperty(properties, CanalConstants.getInstancLazyKey(CanalConstants.GLOBAL_NAME)); if (StringUtils.isNotEmpty(lazyStr)) { globalConfig.setLazy(Boolean.valueOf(lazyStr)); } String managerAddress = getProperty(properties, CanalConstants.getInstanceManagerAddressKey(CanalConstants.GLOBAL_NAME)); if (StringUtils.isNotEmpty(managerAddress)) { if (StringUtils.equals(managerAddress, \"${canal.admin.manager}\")) { managerAddress = adminManagerAddress; } globalConfig.setManagerAddress(managerAddress); } String springXml = getProperty(properties, CanalConstants.getInstancSpringXmlKey(CanalConstants.GLOBAL_NAME)); if (StringUtils.isNotEmpty(springXml)) { globalConfig.setSpringXml(springXml); } instanceGenerator = destination -\u003e { // ... }; return globalConfig; } 2.3.2.1.2 globalInstanceConfig 字段 全局配置，实际上也是一个 InstanceConfig 对象。并且每一个 destination 对应的 InstanceConfig 配置里面都有全局引用的 InstanceConfig。 涉及的配置内容： #canal.admin.manager = 127.0.0.1:8089 canal.instance.global.mode = spring canal.instance.global.lazy = false canal.instance.global.manager.address = ${canal.admin.manager} #canal.instance.global.spring.xml = classpath:spring/memory-instance.xml canal.instance.global.spring.xml = classpath:spring/file-instance.xml #canal.instance.global.spring.xml = classpath:spring/default-instance.xml canal.instance.global.mode 每个 instance 都有各自的配置。instance 的配置也可以放在本地，也可以放在远程配置中心里。如果每个 instance 配置都是一样的，就直接配置这个全局的模式。特别是启用了 admin 的话，强制是 MANAGER；默认的配置启动 server，是 SPRING 模式。目前枚举类 InstanceMode 就这两种选择。你在配置文件的模式如 spring 会自动给你转大写。 canal.instance.global.lazy 是否需要延时加载。 canal.instance.global.manager.address 配置中心地址，默认会使用 canal.admin.manager 的值，如果有远端的配置必须要有值。 canal.instance.global.spring.xml spring配置文件路径。如果 canal.instance.global.mode=spring，需要提供此配置项。 补充知识 – instance 使用 Spring 配置方式： canal/deployer/src/main/resources/spring/base-instance.xml \u003c!-- properties --\u003e \u003cbean class=\"com.alibaba.otter.canal.instance.spring.support.PropertyPlaceholderConfigurer\" lazy-init=\"false\"\u003e \u003cproperty name=\"ignoreResourceNo","date":"2021-01-07","objectID":"/zh-cn/2021/01/07/canal-deployer/:3:2","tags":["canal"],"title":"闲聊 canal | deployer 模块","uri":"/zh-cn/2021/01/07/canal-deployer/"},{"categories":["数据库"],"content":"2.3.2 核心 CanalController#start 方法 等了好久终于到这个启动方法了，从 com.alibaba.otter.canal.deployer.CanalLauncher#main – com.alibaba.otter.canal.deployer.CanalStarter#start – com.alibaba.otter.canal.deployer.CanalController#start 2.3.2.1 代码 public void start() throws Throwable { logger.info(\"## start the canal server[{}({}):{}]\", ip, registerIp, port); // 创建整个canal的工作节点 final String path = ZookeeperPathUtils.getCanalClusterNode(registerIp + \":\" + port); initCid(path); if (zkclientx != null) { this.zkclientx.subscribeStateChanges(new IZkStateListener() { public void handleStateChanged(KeeperState state) throws Exception { } public void handleNewSession() throws Exception { initCid(path); } @Override public void handleSessionEstablishmentError(Throwable error) throws Exception { logger.error(\"failed to connect to zookeeper\", error); } }); } // 优先启动embeded服务 embededCanalServer.start(); // 尝试启动一下非lazy状态的通道 for (Map.Entry\u003cString, InstanceConfig\u003e entry : instanceConfigs.entrySet()) { final String destination = entry.getKey(); InstanceConfig config = entry.getValue(); // 创建destination的工作节点 if (!embededCanalServer.isStart(destination)) { // HA机制启动 ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(destination); if (!config.getLazy() \u0026\u0026 !runningMonitor.isStart()) { runningMonitor.start(); } } if (autoScan) { instanceConfigMonitors.get(config.getMode()).register(destination, defaultAction); } } if (autoScan) { instanceConfigMonitors.get(globalInstanceConfig.getMode()).start(); for (InstanceConfigMonitor monitor : instanceConfigMonitors.values()) { if (!monitor.isStart()) { monitor.start(); } } } // 启动网络接口 if (canalServer != null) { canalServer.start(); } } 跳过 canalMQProducer zk 交互，路径是 /otter/canal/cluster/{0}，其中 {0} 是 IP ＋ 端口，会有多次的 initCid 去创建这个路径 [zk: localhost:2181(CONNECTED) 92] ls /otter/canal/cluster [30.11.176.127:11111] 启动 embededCanalServer，里面会创建 canalInstance，在 server 篇幅展开。 如果没启动，HA 机制监听逻辑会再触发一遍（重复代码，可以提成一个方法） 如果自动扫描，就会注册变化监听，并且会启动整个配置的监听以及每一个 instance 的监听。 CanalServerWithNetty 模式启动，监听客户端的请求，让客户端能获取到 binlog 的变化。 ","date":"2021-01-07","objectID":"/zh-cn/2021/01/07/canal-deployer/:3:3","tags":["canal"],"title":"闲聊 canal | deployer 模块","uri":"/zh-cn/2021/01/07/canal-deployer/"},{"categories":["数据库"],"content":"三、总结 deployer 做了配置的读取，instance 的配置读取方式 deployer 做了配置的变化监听，做了完整的启动|停止，新增|删除操作 deployer 确认 server 启动是单机还是集群，集群的话依赖 Zookeeper deployer 把 server 拉起来，去监听客户端请求 ","date":"2021-01-07","objectID":"/zh-cn/2021/01/07/canal-deployer/:4:0","tags":["canal"],"title":"闲聊 canal | deployer 模块","uri":"/zh-cn/2021/01/07/canal-deployer/"},{"categories":["数据库"],"content":"四、参考 http://www.tianshouzhi.com/api/tutorials/canal/381 https://github.com/alibaba/canal/wiki/AdminGuide https://github.com/alibaba/canal/wiki/canal%E4%BB%8B%E7%BB%8D ","date":"2021-01-07","objectID":"/zh-cn/2021/01/07/canal-deployer/:5:0","tags":["canal"],"title":"闲聊 canal | deployer 模块","uri":"/zh-cn/2021/01/07/canal-deployer/"},{"categories":["数据库"],"content":"本文介绍 canal 的 filter 模块","date":"2021-01-03","objectID":"/zh-cn/2021/01/03/canal-filter/","tags":["canal"],"title":"闲聊 canal | filter 模块","uri":"/zh-cn/2021/01/03/canal-filter/"},{"categories":["数据库"],"content":"一、前言 filter 模块是一个比较简单的模块，主要用于过滤 binlog 过来的表和字段数据。使用 canal 的时候，可以在服务端或客户端进行配置。 ","date":"2021-01-03","objectID":"/zh-cn/2021/01/03/canal-filter/:1:0","tags":["canal"],"title":"闲聊 canal | filter 模块","uri":"/zh-cn/2021/01/03/canal-filter/"},{"categories":["数据库"],"content":"二、内容 ","date":"2021-01-03","objectID":"/zh-cn/2021/01/03/canal-filter/:2:0","tags":["canal"],"title":"闲聊 canal | filter 模块","uri":"/zh-cn/2021/01/03/canal-filter/"},{"categories":["数据库"],"content":"2.1 结构 CanalEventFilter 接口，定义了一个 filter 方法，返回 true | false aviater 下面是实现类 AviaterELFilter EL表达式匹配 AviaterRegexFilter 正则匹配 AviaterSimpleFilter 简单匹配 ","date":"2021-01-03","objectID":"/zh-cn/2021/01/03/canal-filter/:2:1","tags":["canal"],"title":"闲聊 canal | filter 模块","uri":"/zh-cn/2021/01/03/canal-filter/"},{"categories":["数据库"],"content":"2.2 依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.googlecode.aviator\u003c/groupId\u003e \u003cartifactId\u003eaviator\u003c/artifactId\u003e \u003c/dependency\u003e aviator 2.2.1 如果看到这个版本的发布日期，一定让人非常震惊 但是这个 aviator 不是没有更新，相反我发现它一直在稳定的发展，并且最近一年也发布了不少版本。 可怕，canal 这么多年都没有更新过这个库了。 ","date":"2021-01-03","objectID":"/zh-cn/2021/01/03/canal-filter/:2:2","tags":["canal"],"title":"闲聊 canal | filter 模块","uri":"/zh-cn/2021/01/03/canal-filter/"},{"categories":["数据库"],"content":"2.3 代码分析 2.3.1 简单匹配 字段 public class AviaterSimpleFilter implements CanalEventFilter\u003cString\u003e { private static final String SPLIT = \",\"; private static final String FILTER_EXPRESSION = \"include(list,target)\"; private final Expression exp = AviatorEvaluator.compile(FILTER_EXPRESSION, true); private final List\u003cString\u003e list; } exp 匹配的表达式 include(list,target) 表示字符串 list 里面找一个字符串是否存在 构造方法 public AviaterSimpleFilter(String filterExpression){ if (StringUtils.isEmpty(filterExpression)) { list = new ArrayList\u003c\u003e(); } else { String[] ss = filterExpression.toLowerCase().split(SPLIT); list = Arrays.asList(ss); } } 全部转换成小写 根据,分隔，配置多个就 s1.t1,s2.t2，会变成 list [s1.t1, s2.t2] 匹配方法 public boolean filter(String filtered) throws CanalFilterException { if (list.isEmpty()) { return true; } if (StringUtils.isEmpty(filtered)) { return true; } Map\u003cString, Object\u003e env = new HashMap\u003c\u003e(); env.put(\"list\", list); env.put(\"target\", filtered.toLowerCase()); return (Boolean) exp.execute(env); } 空字符串直接是 true 会转小写去比较 2.3.2 正则匹配 字段 public class AviaterRegexFilter implements CanalEventFilter\u003cString\u003e { private static final String SPLIT = \",\"; private static final String PATTERN_SPLIT = \"|\"; private static final String FILTER_EXPRESSION = \"regex(pattern,target)\"; private static final RegexFunction regexFunction = new RegexFunction(); private final Expression exp = AviatorEvaluator.compile(FILTER_EXPRESSION, true); static { AviatorEvaluator.addFunction(regexFunction); } private static final Comparator\u003cString\u003e COMPARATOR = new StringComparator(); final private String pattern; final private boolean defaultEmptyValue; } exp 匹配的表达式 regex(pattern,target) 表示字符串 list 里面找一个字符串是否存在 regexFunction 在静态方法设置了默认的正则函数 defaultEmptyValue 空值匹配条件 pattern 正则的表达式 构造方法 public AviaterRegexFilter(String pattern){ this(pattern, true); } public AviaterRegexFilter(String pattern, boolean defaultEmptyValue){ this.defaultEmptyValue = defaultEmptyValue; List\u003cString\u003e list = null; if (StringUtils.isEmpty(pattern)) { list = new ArrayList\u003c\u003e(); } else { String[] ss = StringUtils.split(pattern, SPLIT); list = Arrays.asList(ss); } // 对pattern按照从长到短的排序 // 因为 foo|foot 匹配 foot 会出错，原因是 foot 匹配了 foo 之后，会返回 foo，但是 foo 的长度和 foot // 的长度不一样 list.sort(COMPARATOR); // 对pattern进行头尾完全匹配 list = completionPattern(list); this.pattern = StringUtils.join(list, PATTERN_SPLIT); } 默认空值匹配 会对分隔后的匹配表达式进行排序 list.sort(COMPARATOR) 和头尾匹配 completionPattern，如果传入 foooo,f.*t 即变成 ^foooo$ 和 ^f.*t$ 每部分会通过 | 组合在一起，即 ^foooo$|^f.*t$ 匹配方法 public boolean filter(String filtered) throws CanalFilterException { if (StringUtils.isEmpty(pattern)) { return defaultEmptyValue; } if (StringUtils.isEmpty(filtered)) { return defaultEmptyValue; } Map\u003cString, Object\u003e env = new HashMap\u003c\u003e(); env.put(\"pattern\", pattern); env.put(\"target\", filtered.toLowerCase()); return (Boolean) exp.execute(env); } 空字符串返回的是 defaultEmptyValue 会转小写去比较 执行逻辑 public class RegexFunction extends AbstractFunction { public AviatorObject call(Map\u003cString, Object\u003e env, AviatorObject arg1, AviatorObject arg2) { String pattern = FunctionUtils.getStringValue(arg1, env); String text = FunctionUtils.getStringValue(arg2, env); Perl5Matcher matcher = new Perl5Matcher(); boolean isMatch = matcher.matches(text, PatternUtils.getPattern(pattern)); return AviatorBoolean.valueOf(isMatch); } public String getName() { return \"regex\"; } } name 是和 FILTER_EXPRESSION regex(pattern,target) 中的前面部分匹配，这样在执行的时候会调用到 call 方法 env 内容是包含 key pattern 和 target 的一个 map，这个就是在 filter 方法中设置进去的 arg1 是 pattern，arg2 是 target，和表达式一致 2.3.3 EL表达式匹配 字段 public class AviaterELFilter implements CanalEventFilter\u003cCanalEntry.Entry\u003e { public static final String ROOT_KEY = \"entry\"; private String expression; } ROOT_KEY 默认是 entry，对应类型 CanalEntry.Entry expression 表达式，比如 str(entry.entryType) == 'ROWDATA' 构造方法 public AviaterELFilter(String expression){ this.expression = expression; } 匹配方法 public boolean filter(CanalEntry.Entry entry) throws CanalFilterException { if (StringUtils.isEmpty(expression)) { return true; } Map\u003cString, Object\u003e env = ne","date":"2021-01-03","objectID":"/zh-cn/2021/01/03/canal-filter/:2:3","tags":["canal"],"title":"闲聊 canal | filter 模块","uri":"/zh-cn/2021/01/03/canal-filter/"},{"categories":["数据库"],"content":"2.4 配置说明 2.4.1 服务端配置 在 canal 里面的使用的例子 监听的库和表 # table regex canal.instance.filter.regex=.*\\\\..* # table black regex canal.instance.filter.black.regex=canal_manager\\\\..* 监听所有的内容，然后去掉库 canal_manager 下的所有表 监听的字段 # 只监听 tc_king 这个表的五个字段，其它字段都会忽略 canal.instance.filter.field=base_test.tc_king:id/name/career/remark/way # 会忽略 tc_king 这个表的 id,name 字段 canal.instance.filter.black.field=base_test.tc_king:id/name 这个场景应对某个字段可以在不同的区域是可以改的，比如有一个规则表，100条规则，从A集群的数据库同步到其它集群的数据库，其它数据库里面这100条规则的状态是自己维护的，新增后也需要手动去操作开启，那么就不需要监听这个字段了。 可以看到加了 black 的是黑名单，不加的就是白名单了。 2.4.2 客户端配置 这个我第一时间想到的是：如果监听某个库有20张表，A集群只需要关心其中的5张表，B集群只关心另外的8张表，那么就需要不同的client端配置了。 然后现实很残酷，由于目前一个 canal instance 只允许一个 client 订阅，因此目前还达不到这种效果。 /** * 客户端订阅，重复订阅时会更新对应的filter信息 * * \u003cpre\u003e * 说明： * a. 如果本次订阅中filter信息为空，则直接使用canal server服务端配置的filter信息 * b. 如果本次订阅中filter信息不为空，目前会直接替换canal server服务端配置的filter信息，以本次提交的为准 * * TODO: 后续可以考虑，如果本次提交的filter不为空，在执行过滤时，是对canal server filter + 本次filter的交集处理，达到只取1份binlog数据，多个客户端消费不同的表 * \u003c/pre\u003e * * @throws CanalClientException */ void subscribe(String filter) throws CanalClientException; /** * 客户端订阅，不提交客户端filter，以服务端的filter为准 * * @throws CanalClientException */ void subscribe() throws CanalClientException; 我们公司的业务场景，目前就是需要给不同的 client 同步不同的库和不同的表内容，我们在中间做了一层数据工单，后续补充。 ","date":"2021-01-03","objectID":"/zh-cn/2021/01/03/canal-filter/:2:4","tags":["canal"],"title":"闲聊 canal | filter 模块","uri":"/zh-cn/2021/01/03/canal-filter/"},{"categories":["数据库"],"content":"三、参考 https://github.com/killme2008/aviatorscript [https://www.yuque.com/boyan-avfmj/aviatorscript]https://www.yuque.com/boyan-avfmj/aviatorscript 这个aviator的文档居然在语雀个人账号下的，无奈 ","date":"2021-01-03","objectID":"/zh-cn/2021/01/03/canal-filter/:3:0","tags":["canal"],"title":"闲聊 canal | filter 模块","uri":"/zh-cn/2021/01/03/canal-filter/"},{"categories":["数据库"],"content":"本文介绍 canal 的使用和概念","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"一、前言 闲聊 canal 系列基于版本 1.1.5 介绍下今天的猪脚 canal 官方定位 基于数据库增量日志解析，提供增量数据订阅\u0026消费，目前主要支持了mysql 业务场景 基于日志增量订阅\u0026消费支持的业务： 数据库镜像 数据库实时备份 多级索引 (卖家和买家各自分库索引) search build 业务cache刷新 价格变化等重要业务消息 ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:1:0","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"二、原理介绍 ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:2:0","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"2.1 MySQL 主备复制 从上层来看，复制分成三步： master 将改变记录到**二进制日志(binary log)**中（这些记录叫做二进制日志事件，binary log events，可以通过 show binlog events 进行查看）； slave 将 master 的 binary log events 拷贝到它的中继日志(relay log)； slave 重做中继日志中的事件，将改变反映它自己的数据。 ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:2:1","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"2.2 canal 的工作原理 原理相对比较简单： canal 模拟 mysql slave 的交互协议，伪装自己为 mysql slave，向 mysql master 发送 dump 协议 mysql master 收到 dump 请求，开始推送 binary log 给 slave(也就是canal) canal 解析 binary log 对象(原始为 byte 流) ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:2:2","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"2.3 canal 架构 说明： server 代表一个 canal 运行实例，对应于一个 jvm instance 对应于一个数据队列 （1个 server 对应 1..n 个 instance) instance 模块： eventParser (数据源接入，模拟slave协议和master进行交互，协议解析) eventSink (Parser和Store链接器，进行数据过滤，加工，分发的工作) eventStore (数据存储) metaManager (增量订阅\u0026消费信息管理器) 概念还是建议都看看，会方便看源码 对应的源码结构 目录结构把每个模块都很清晰的展示出来了，肉眼直接识别（顾名思义）。 简单描述下每个模块的功能： common模块：主要是提供了一些公共的工具类和接口。 connector模块：提供 mq 交互的能力，里面有类似于 dubbo 的 @SPI 机制 deployer模块：通过该模块提供的CanalLauncher来启动canal server filter模块：给 parse 和 sink 模块提供 filter 能力的模块 client模块：canal的客户端。核心接口为 CanalConnector client-adapter：内置客户端数据同步功能 example模块：提供 client 模块使用案例。 protocol模块：client和server模块之间的通信协议 server模块：canal服务器端。核心接口为CanalServer instance模块：一个server有多个instance。每个instance都会模拟成一个mysql实例的slave。instance模块有四个核心组成部分：parser模块、sink模块、store模块，meta模块。核心接口为CanalInstance parser模块：数据源接入，模拟slave协议和master进行交互，协议解析。parser模块依赖于dbsync、driver模块。 driver模块和dbsync模块：从这两个模块的artifactId(canal.parse.driver、canal.parse.dbsync)，就可以看出来，这两个模块实际上是parser模块的组件。事实上parser 是通过driver模块与mysql建立连接，从而获取到binlog。由于原始的binlog都是二进制流，需要解析成对应的binlog事件，这些binlog事件对象都定义在dbsync模块中，dbsync 模块来自于淘宝的tddl。 sink模块：parser和store链接器，进行数据过滤，加工，分发的工作。核心接口为CanalEventSink store模块：数据存储。核心接口为CanalEventStore meta模块：增量订阅\u0026消费信息管理器，核心接口为CanalMetaManager，主要用于记录canal消费到的mysql binlog的位置， ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:2:3","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"三、准备 MySQL 默认已经安装好 MySQL ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:3:0","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"3.1 检查 MySQL 是否满足要求 Mac 系统 启动 $ sudo support-files/mysql.server start Starting MySQL SUCCESS! 连接 $ mysql -u root Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 4 Server version: 5.7.22-log MySQL Community Server (GPL) Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql\u003e 查看 mysql\u003e show variables like '%log_bin%'; +---------------------------------+---------------------------------------+ | Variable_name | Value | +---------------------------------+---------------------------------------+ | log_bin | ON | | log_bin_basename | /usr/local/mysql/data/mysql-bin | | log_bin_index | /usr/local/mysql/data/mysql-bin.index | | log_bin_trust_function_creators | OFF | | log_bin_use_v1_row_events | OFF | | sql_log_bin | ON | +---------------------------------+---------------------------------------+ 6 rows in set (0.01 sec) log_bin 必须是 ON，如果是 OFF 则需要编辑配置文件 my.cnf ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:3:1","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"3.2 配置 MySQL $ cat /etc/my.cnf [mysqld] log-bin=mysql-bin # 开启 binlog binlog-format=ROW # 选择 ROW 模式 server_id=1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复 配置了后需要重启 mysql 服务 目前 canal 支持所有模式的增量订阅(但配合同步时，因为 statement 只有sql，没有数据，无法获取原始的变更日志，所以一般建议为ROW模式) ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:3:2","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"3.3 设置账号 -- 创建账号，可以使用已有账号 CREATE USER canal IDENTIFIED BY 'canal'; -- 授权 GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'canal'@'%'; -- GRANT ALL PRIVILEGES ON *.* TO 'canal'@'%' ; FLUSH PRIVILEGES; MySQL slave 的权限需要 SELECT, REPLICATION SLAVE, REPLICATION CLIENT 因为 canal 账号后续 admin 模块使用，需要删除和编辑权限，直接用GRANT ALL PRIVILEGES ON *.* TO 'canal'@'%' ; 更方便。 ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:3:3","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"四、运行单机例子 ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:4:0","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"4.1 使用下载包 参考官方文档 默认配置只需要改 instance 的配置，我这里没有主从的配置，就一台 MySQL，关注下面配置项： # 主库的地址 canal.instance.master.address=127.0.0.1:3306 # 数据库账号密码（有 slave 权限） canal.instance.dbUsername=canal canal.instance.dbPassword=canal # 这个你可以自指定，不过大于 v1.0.26+ 会自动创建 # canal.instance.mysql.slaveId=0 不过如果你的运行环境是单核的，需要将 canal.properties 下的 canal.instance.parser.parallel 设置为 false。 instance 的名称对应的是文件夹，如下 example $ ls -l total 48 -rwxrwxrwx@ 1 tc staff 5794 12 28 15:57 canal.properties -rwxrwxrwx@ 1 tc staff 291 8 31 2019 canal_local.properties drwxrwxrwx@ 5 tc staff 160 12 28 15:14 example -rwxrwxrwx@ 1 tc staff 3437 2 28 2020 logback.xml drwxrwxrwx@ 3 tc staff 96 11 27 2018 metrics drwxrwxrwx@ 8 tc staff 256 8 22 13:14 spring -rwxrwxrwx@ 1 tc staff 2124 12 28 16:24 sync_dev.properties 运行起来后默认是文件模式，会创建文件： $ ls -l total 1912 -rw-r--r--@ 1 tc staff 913408 12 30 13:37 h2.mv.db -rwxrwxrwx@ 1 tc staff 2106 8 22 13:14 instance.properties -rw-r--r--@ 1 tc staff 338 12 30 13:37 meta.dat ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:4:1","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"4.2 镜像 参考官方文档 下载脚本执行： sh run.sh -e canal.auto.scan=false -e canal.destinations=base_test -e canal.instance.master.address=127.0.0.1:3306 -e canal.instance.dbUsername=canal -e canal.instance.dbPassword=canal -e canal.instance.connectionCharset=UTF-8 -e canal.instance.tsdb.enable=true -e canal.instance.gtidon=false; 查看镜像的运行情况： $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6b022c5f435f canal/canal-server \"/alidata/bin/main.s…\" About a minute ago Up About a minute 0.0.0.0:9100-\u003e9100/tcp, 0.0.0.0:11110-11112-\u003e11110-11112/tcp canal-server 查看镜像日志： $ docker logs 6b022c5f435f DOCKER_DEPLOY_TYPE=VM ==\u003e INIT /alidata/init/02init-sshd.sh ==\u003e EXIT CODE: 0 ==\u003e INIT /alidata/init/fix-hosts.py ==\u003e EXIT CODE: 0 ==\u003e INIT DEFAULT Generating SSH1 RSA host key: [ OK ] Starting sshd: [ OK ] Starting crond: [ OK ] ==\u003e INIT DONE ==\u003e RUN /home/admin/app.sh ==\u003e START ... start canal ... start canal successful ==\u003e START SUCCESSFUL ... START SUCCESSFUL ... 表示成功 按手册镜像启动报数据库连接错误 （https://github.com/alibaba/canal/issues/1339） ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:4:2","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"4.3 Intellij 启动 把 canal/deployer/src/main/resources/logback.xml 文件的日志路径改下： \u003cFile\u003e../logs/${destination}/${destination}.log\u003c/File\u003e \u003cFile\u003e/Users/tc/Documents/workspace_2020/canal/logs/${destination}/${destination}.log\u003c/File\u003e 找到 com.alibaba.otter.canal.deployer.CanalLauncher#main 然后直接运行即可。 运行后控制台也没啥日志，可以在 canal/logs 下看到日志。 正常启动日志： 2020-12-30 11:14:01.111 [main] INFO com.alibaba.otter.canal.deployer.CanalLauncher - ## set default uncaught exception handler 2020-12-30 11:14:01.159 [main] INFO com.alibaba.otter.canal.deployer.CanalLauncher - ## load canal configurations 2020-12-30 11:14:02.266 [main] INFO com.alibaba.otter.canal.deployer.CanalStarter - ## start the canal server. 2020-12-30 11:14:02.360 [main] INFO com.alibaba.otter.canal.deployer.CanalController - ## start the canal server[30.11.176.115(30.11.176.115):11111] 2020-12-30 11:14:02.497 [main] INFO com.alibaba.otter.canal.deployer.CanalStarter - ## the canal server is running now ...... ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:4:3","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"五、运行 admin ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:5:0","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"5.1 创建数据库表 先要把 admin 项目依赖的数据库创建好 找到SQL 初始化SQL 命令操作 # 连接到数据库 mysql -u root -p # 导入初始化SQL \u003e source conf/canal_manager.sql 一般用 Navicat 操作，直接通过有权限的账号连接上去，然后执行SQL内容即可。 ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:5:1","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"5.2 Intellij 启动 运行 直接启动会报错： Caused by: io.ebean.config.BeanNotEnhancedException: Bean class com.alibaba.otter.canal.admin.model.CanalConfig is not enhanced? Check packages specified in ebean.mf. If you are running in IDEA or Eclipse check that the enhancement plugin is installed. See https://ebean.io/docs/trouble-shooting#not-enhanced at io.ebeaninternal.server.deploy.BeanDescriptorManager.setEntityBeanClass(BeanDescriptorManager.java:1580) at io.ebeaninternal.server.deploy.BeanDescriptorManager.createByteCode(BeanDescriptorManager.java:1445) at io.ebeaninternal.server.deploy.BeanDescriptorManager.readDeployAssociations(BeanDescriptorManager.java:1354) at io.ebeaninternal.server.deploy.BeanDescriptorManager.readEntityDeploymentAssociations(BeanDescriptorManager.java:770) at io.ebeaninternal.server.deploy.BeanDescriptorManager.deploy(BeanDescriptorManager.java:374) at io.ebeaninternal.server.core.InternalConfiguration.\u003cinit\u003e(InternalConfiguration.java:197) at io.ebeaninternal.server.core.DefaultContainer.createServer(DefaultContainer.java:124) at io.ebeaninternal.server.core.DefaultContainer.createServer(DefaultContainer.java:35) at io.ebean.EbeanServerFactory.createInternal(EbeanServerFactory.java:109) at io.ebean.EbeanServerFactory.create(EbeanServerFactory.java:70) at com.alibaba.otter.canal.admin.config.EbeanConfig.ebeanServer(EbeanConfig.java:38) at com.alibaba.otter.canal.admin.config.EbeanConfig$$EnhancerBySpringCGLIB$$1b6fbe49.CGLIB$ebeanServer$0(\u003cgenerated\u003e) at com.alibaba.otter.canal.admin.config.EbeanConfig$$EnhancerBySpringCGLIB$$1b6fbe49$$FastClassBySpringCGLIB$$3981d1d4.invoke(\u003cgenerated\u003e) at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228) at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:361) at com.alibaba.otter.canal.admin.config.EbeanConfig$$EnhancerBySpringCGLIB$$1b6fbe49.ebeanServer(\u003cgenerated\u003e) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:566) at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ... 17 common frames omitted 新知识点 ebean 首先需要安装插件： 在 Build 下开启 Ebean enhancement 正常启动就是熟悉的 springboot 项目的启动日志。 验证 输入地址 127.0.0.1:8089 默认密码：admin/123456 ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:5:2","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"5.3 镜像启动 参照官方文档 正常使用一个开源中间件，不可能拿来跑个镜像就完事了，肯定要本地的 IDE 启动查看整个代码流程，所以镜像这块就跳过了。 ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:5:3","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"5.4 控制台 控制页面可以看到： 可以看到启动了一个单节点的 server，它的状态是启动。 刚开始的时候 instance 列表会是停止状态，正常情况下过会会自动的变成启动 ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:5:4","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"六、运行集群例子 ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:6:0","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"6.1 canal 的 HA 分 server 和 client 的 HA canal server: 为了减少对 mysql dump 的请求，不同 server 上的 instance 要求同一时间只能有一个处于running，其他的处于 standby 状态. canal client: 为了保证有序性，一份 instance 同一时间只能由一个 canal client 进行 get/ack/rollback 操作，否则客户端接收无法保证有序。 也就是说数据库实例的 binglog 是单线程操作的 大致步骤： canal server 要启动某个 canal instance 时都先向zookeeper进行一次尝试启动判断 (实现：创建EPHEMERAL节点，谁创建成功就允许谁启动) 创建 zookeeper 节点成功后，对应的canal server就启动对应的 canal instance，没有创建成功的 canal instance 就会处于standby状态 一旦 zookeeper 发现 canal server A 创建的节点消失后，立即通知其他的 canal server 再次进行步骤1的操作，重新选出一个 canal server 启动 instance. canal client 每次进行 connect 时，会首先向 zookeeper 询问当前是谁启动了 canal instance，然后和其建立链接，一旦链接不可用，会重新尝试 connect. canal client 的方式和 canal server 方式类似，也是利用 zookeeper 的抢占 EPHEMERAL 节点的方式进行控制。 ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:6:1","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"6.2 通过 admin 配置 新建集群 只需要关心 Zookeeper 的地址和集群的名称 新建后会在列表页面看到 server启动 面向容器无状态的运维 server 的信息维护除了在 canal-admin 上基于 WebUI 的操作以外，还有更加方便的 auto register 机制，主要针对面向容器化之后可以通过扩容节点，自动完成集群配置的维护和 instance 分流 # 是否开启自动注册模式 canal.admin.register.auto = true # 可以指定默认注册的集群名，如果不指定，默认注册为单机模式 canal.admin.register.cluster = 我的配置 canal_local.properties canal.admin.register.auto = true canal.admin.register.cluster = local_cluster 使用ZK去存储，需要改： canal.instance.global.spring.xml = classpath:spring/default-instance.xml ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:6:2","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"七、小结 admin模块启动配置好 cluster、server 和 instance 后，就算宕机也不影响 server 和 client 的交互，因为他们是直接建立的 TCP 连接。 canal.serverMode = tcp 如果没有 admin 模块，无法最简配置启动 server，并且需要有集群配置才能启动 server。 权限配置别漏了 server 启动，连接上 admin 的时候，需要插入数据，如果授权的时候就用了 GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'canal'@'%'; 那么默认权限是不够的，启动后日志文件会出现如下错误： 2020-12-30 10:59:36.573 [main] INFO com.alibaba.otter.canal.deployer.CanalLauncher - ## set default uncaught exception handler 2020-12-30 10:59:36.609 [main] INFO com.alibaba.otter.canal.deployer.CanalLauncher - ## load canal configurations 2020-12-30 10:59:37.316 [main] ERROR com.alibaba.otter.canal.deployer.CanalLauncher - ## Something goes wrong when starting up the canal Server: com.alibaba.otter.canal.common.CanalException: load manager config failed. Caused by: com.alibaba.otter.canal.common.CanalException: requestGet for canal config error: Error[INSERT command denied to user 'canal'@'localhost' for table 'canal_node_server'] admin 默认配置是 canal 和 canal spring.datasource:address:127.0.0.1:3306database:canal_managerusername:canalpassword:canal ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:7:0","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["数据库"],"content":"八、参考 https://github.com/alibaba/canal/wiki/%E7%AE%80%E4%BB%8B http://dev.mysql.com/doc/refman/5.5/en/binary-log.html http://www.taobaodba.com/html/474_mysqls-binary-log_details.html https://docs.google.com/presentation/d/1MkszUPYRDkfVPz9IqOT1LLT5d9tuwde_WC8GZvjaDRg/ ","date":"2021-01-01","objectID":"/zh-cn/2021/01/01/canal-prepare/:8:0","tags":["canal"],"title":"闲聊 canal | 入门篇","uri":"/zh-cn/2021/01/01/canal-prepare/"},{"categories":["json","go源码"],"content":"一、前言 其实本篇应该写的是json的反序列化，所以花了几个晚上看了下该部分源码，每次看都想睡觉。为什么呢？因为确实是太无聊了，我打赌这是我看过go源码中最无聊的逻辑，全篇都是一些状态的切换，要么是 if ... else ... ，要么就是 switch ... case ... case ...,头大。我也尝试画过流程图，但是这么多状态的切换，也不知道是什么力量支撑我画了2天时间，最后我放弃了-画出来没有丝毫意义。所以本篇我就源码层面顺着json：你或许还不知道的使用的坑（一）续写下反序列化可能会遇到的一些坑或者未知的使用方法。 ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:0:0","tags":["json","源码","golang"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json","go源码"],"content":"tips: 我在看的过程中也留了些注释，看兴趣的话可以去GitHub上去看看，也欢迎你的加入。 所有代码在 The Go Playground都能看到。 二、内容 ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:1:0","tags":["json","源码","golang"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json","go源码"],"content":"1.反序列化科学计数法 假如你有这么个json字符串，如何序列化呢？ { \"Name\": \"zhangSan\", \"Age\": -0e+10000 } 注意Age字段的值并没有被双引号包围，所以go提供了一种类型json.Number专门用来装数字，包括科学计数法和普通数字。下面是我的结构体： type User struct { Name string Age json.Number } 运行我的示例代码能得到正确结果： {zhangSan -0e+10000} ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:2:0","tags":["json","源码","golang"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json","go源码"],"content":"2.value是null的注意 假如我有这么个json字符串： { \"Name\": null, \"Age\": null } 且我的结构体是这样的： type User struct { Name string Age map[string]string } 我的序列化代码如下: var san = User{ Name: \"aaa\", Age: map[string]string{\"1\": \"1\"}, } err := json.Unmarshal(bytes, \u0026san) if err != nil { fmt.Println(\"error:\", err) } else { fmt.Println(san) } 你觉得打印结果会是神马样子的呢？ {aaa map[]} 会有点不可思议是吧？为什么Name的值没有改变，但是Age确被重新初始化了呢？ go的官方序列化代码如下: case 'n': // null // The main parser checks that only true and false can reach here, // but if this was a quoted string input, it could be anything. if fromQuoted \u0026\u0026 string(item) != \"null\" { // 字段有',string'标签，以n开头，必须是null d.saveError(fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal %q into %v\", item, v.Type())) break } switch v.Kind() { case reflect.Interface, reflect.Ptr, reflect.Map, reflect.Slice: // 设置给interface{},指针,map,切片一个初始化的值 v.Set(reflect.Zero(v.Type())) // otherwise, ignore null for primitives/string } ok,能看到10~12行把该字段重新设置为0值了,不仅map,还有interface,指针,slice都会发生这种情况，除了这种情况，其他的值都不会被改变。 ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:3:0","tags":["json","源码","golang"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json","go源码"],"content":"3.反序列到接口，必须是空接口 常理任何json字段都可以序列化到接口的，但是需要注意下，go只允许空接口 interface{}，如果你的接口有方法的话是不被允许的。例如你有如下结构体： type User struct { Name string Age interface { GetAge() int } } 可以看到 Age字段是一个非空接口，当我反序列化该json字符串的时候： { \"Name\": null, \"Age\": 19 } 会发生异常,示例代码： error: json: cannot unmarshal number into Go struct field User.Age of type interface { GetAge() int } go的代码在这里: case reflect.Interface: if v.NumMethod() == 0 { // 空接口 v.Set(reflect.ValueOf(value)) } else { // 非空接口 d.saveError(\u0026UnmarshalTypeError{Value: \"bool\", Type: v.Type(), Offset: int64(d.readIndex())}) // 接口 } v.NumMethod() == 0表示必须是个空接口。 ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:4:0","tags":["json","源码","golang"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json","go源码"],"content":"4.不要把数组当做反序列化的字段类型 ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:5:0","tags":["json","源码","golang"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json","go源码"],"content":"4.1 虽然说一般来说我们都是用切片，但是也还是拎出来讲一讲下，可能会导致少反序列化些数组值。 假如我有这么个结构体： type User struct { Name string Age [1]int } 而我的json字符串长这样: { \"Name\": \"zhangSan\", \"Age\": [20,21] } 反序列化代码的结果如下: {zhangSan [20]} 可以看到只序列化了数组的长度个数，其他都被抛弃了，而且没有任何错误提示。 go的源码在这里: if i \u003c v.Len() { // Decode into element. if err := d.value(v.Index(i)); err != nil { return err } } else { // Ran out of fixed array: skip. if err := d.value(reflect.Value{}); err != nil { return err } } i表示json字符串里面的数组的长度，因为 i大于 v.Len()（数组的长度)的时候，就表示结构体的数组太短了，在第8行简单的忽略了。 ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:5:1","tags":["json","源码","golang"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json","go源码"],"content":"4.2 当数组被初始化过非0值，反序列化会被置为0 结构体如下： type User struct { Name string Age [2]int } 反序列化代码如下： var data = []byte (` { \"Name\": \"zhangSan\", \"Age\": [20] } `) var san = User{ Age: [2]int{1, 2}, } err := json.Unmarshal(data, \u0026san) if err != nil { fmt.Println(\"error:\", err) } else { fmt.Println(san) } 在第8行被初始化之后，反序列化之后结果就是为0值了，结果如下: {zhangSan [20 0]} go得源码在这里: if i \u003c v.Len() { if v.Kind() == reflect.Array { // Array. Zero the rest. z := reflect.Zero(v.Type().Elem()) for ; i \u003c v.Len(); i++ { v.Index(i).Set(z) } } else { v.SetLen(i) } } i表示的是json字符串的数组的长度，当 i小于v.Len()(数组的长度)的时候，会把元素设置为reflect.Zero(v.Type().Elem())。 ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:5:2","tags":["json","源码","golang"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json","go源码"],"content":"5.map的key不是int或者string，怎么操作？ 一招解决：实现接口encoding.TextUnmarshaler。这个我就不举列子了。 go的源码在这： switch v.Kind() { case reflect.Map: // Map key must either have string kind, have an integer kind, // or be an encoding.TextUnmarshaler. switch t.Key().Kind() { case reflect.String, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr: default: if !reflect.PtrTo(t.Key()).Implements(textUnmarshalerType) { d.saveError(\u0026UnmarshalTypeError{Value: \"object\", Type: t, Offset: int64(d.off)}) d.skip() return nil } } if v.IsNil() { v.Set(reflect.MakeMap(t)) } 当时map类型的时候，key不是string或者integer,那么如果实现了textUnmarshalerType也是可以的。 三、另外一种装逼的反序列方式 你可知除了json.Unmarshal()这种方式，还有另外一种反序列的编码方式: var data = []byte (` { \"Name\": \"zhangSan\", \"Age\": 19 } `) var san = User{ } decoder := json.NewDecoder(bytes.NewReader(data)) decoder.Decode(\u0026san) if err != nil { fmt.Println(\"error:\", err) } else { fmt.Println(san) } 当然装逼不是目的，目的是我们能做更多的反序列化的行为控制. ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:6:0","tags":["json","源码","golang"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json","go源码"],"content":"1.把数字当做json.Number类型反序列化到接口里面去 这样有什么意义呢？因为go的做法是默认把数字反序列化成float64类型，但是当该数字很大的时候，float64是表示不了的，所以此时就要用json.Number，但是用json.Unmarshal()是做不到的，此时用json.NewDecoder()就可以的。 下面是错误的示例代码： type User struct { Name string Age interface{} } func main() { var data = []byte (` { \"Name\": \"zhangSan\", \"Age\": 2e+1000 } `) var san = User{ } decoder := json.NewDecoder(bytes.NewReader(data)) //decoder.UseNumber() err := decoder.Decode(\u0026san) if err != nil { fmt.Println(\"error:\", err) } else { fmt.Println(san) } } 错误结果如下： error: json: cannot unmarshal number 2e+1000 into Go struct field User.Age of type float64 只需要把第16行的代码取消注释即可达到目的。 让我们看看go的源码说明: // UseNumber causes the Decoder to unmarshal a number into an interface{} as a // Number instead of as a float64. func (dec *Decoder) UseNumber() { dec.d.useNumber = true } 注释已经讲的很明白了。 再看看具体怎么使用useNumber这个参数的： // convertNumber converts the number literal s to a float64 or a Number // depending on the setting of d.useNumber. func (d *decodeState) convertNumber(s string) (interface{}, error) { if d.useNumber { return Number(s), nil } f, err := strconv.ParseFloat(s, 64) if err != nil { return nil, \u0026UnmarshalTypeError{Value: \"number \" + s, Type: reflect.TypeOf(0.0), Offset: int64(d.off)} } return f, nil } 第4~5行也说明了使用json.Number类型获得结果。 ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:7:0","tags":["json","源码","golang"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json","go源码"],"content":"2.当json字符串某个字段没有在结构体中对应的时候 默认情况下json是允许这种情况下的，那如何禁止这种情况呢？ 这是我的结构体： type User struct { Name string Age interface{} } 我的json字符串： { \"Name\": \"zhangSan\", \"Age\": 2e+1000, \"Head\": \"http://head.jpg\" } 我的反序列化代码: var san = User{ } decoder := json.NewDecoder(bytes.NewReader(data)) decoder.UseNumber() decoder.DisallowUnknownFields() err := decoder.Decode(\u0026san) if err != nil { fmt.Println(\"error:\", err) } else { fmt.Println(san) } 结果会报错，提示找不到Head字段： error: json: unknown field \"Head\" json的源码在这里： if d.disallowUnknownFields { // 判断是否允许没有字段可序列化的情况 d.saveError(fmt.Errorf(\"json: unknown field %q\", key)) } 四、写到最后 上面总结了反序列化的注意一点，由于我的水平有限，并且我也是根据源码倒推过来的，可能还有更深层次的技巧或坑我还没有发现。如果你在工作过程中遇到序列化或者反序列化的问题，欢迎和我交流。可以加我微信，或者微信公众号，我会长期输出原创文章。 我的微信： 我的微信公众号: ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:8:0","tags":["json","源码","golang"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["go源码"],"content":"本文是 map 源码系列第一篇，带你走进 map 为什么分析map 在计算机编程语言当中，用的最多的数据结构估计就是map。map以他近乎o(1)的查找效率和修改效率让他在大多数场景下都比较受青睐。map的常规的实现方式都是hash+其他数据结构，如java是hash+红黑树，而我现在即将要分析的go的实现方式是hash+链表。我会分析map的几乎每段代码，并且在我的GitHub可以查看到我的分析，注释十分详尽，欢迎批评指正。我的打算是把一些常用的数据结构都分析一遍，如果有志同道合的人，可以联系我。 ","date":"2020-11-25","objectID":"/zh-cn/2020/11/25/go-sourcecode-map-first/:0:0","tags":["map","源码","golang"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"我的环境 为了给那些感兴趣看源码分析我的博客的同学阅读得更加清晰，列举了我的环境： go1.14.7 amd64； windows和mac接口，linux没有测试，估计没问题 ； goland,目前最好的golang ide，虽然笔者用起来感觉还是不太完美； 着重分析map[string]string，其他类型的源码变化不大 ； ","date":"2020-11-25","objectID":"/zh-cn/2020/11/25/go-sourcecode-map-first/:1:0","tags":["map","源码","golang"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"本篇重点 1.go的map和java的map有区别，go中是一个关键字，而java确实可以直接查看源码，那么如何分析go的map源码？ 2.调试过程当中，go充斥着大量指针，如何知道指针指向的内容？map的最小单位bmap除了查看tophash，怎么查看里面的其他隐藏字段？ 3.go的map源码为何给不同的key的类型设计不同的实现？ 4.其他一些查看源码的小技巧：内存对齐、指针偏移、类型大小等等 ","date":"2020-11-25","objectID":"/zh-cn/2020/11/25/go-sourcecode-map-first/:2:0","tags":["map","源码","golang"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"如何找到map对应的源码 go的map的结构体是hmap，代码位于runtime/map.go,当编译器编译你申明使用map的源码时候，其实是使用了runtime/map*.go,后面对map的增删改查都是执行该代码，故要弄懂map的底层原理只需要分析该源码，也可以断点调试。 我下面有个自己测试的源码，注意我编译之后查看，就可以发现端倪： package main import \"fmt\" func main() { m1 := make(map[string]string) fmt.Println(m1) m2 := make(map[string]string, 8) fmt.Println(m2) m3 := make(map[string]string, 9) fmt.Println(m3) m4 := map[string]string{} fmt.Println(m4) m3[\"1\"] = \"2\" for k, v := range m3 { fmt.Println(k) fmt.Println(v) } v1 := m3[\"1\"] fmt.Println(v1) if v2, ok := m3[\"1\"]; ok { fmt.Println(v2) } } 上面代码有几种不同申明map的方式，对应runtime/map.go也不同。还有赋值和遍历查找的代码。 下面编译得到汇编指令文件，执行 go tool compile -N -l -S main.go \u003e main.txt 生成了汇编指令文件: \"\".main STEXT size=1891 args=0x0 locals=0x288 0x0000 00000 (main.go:5) TEXT \"\".main(SB), ABIInternal, $648-0 0x0000 00000 (main.go:5) MOVQ TLS, CX 0x0009 00009 (main.go:5) PCDATA $0, $-2 0x0009 00009 (main.go:5) MOVQ (CX)(TLS*2), CX 0x0010 00016 (main.go:5) PCDATA $0, $-1 0x0010 00016 (main.go:5) LEAQ -520(SP), AX 0x0018 00024 (main.go:5) CMPQ AX, 16(CX) 0x001c 00028 (main.go:5) PCDATA $0, $-2 0x001c 00028 (main.go:5) JLS 1881 0x0022 00034 (main.go:5) PCDATA $0, $-1 0x0022 00034 (main.go:5) SUBQ $648, SP 0x0029 00041 (main.go:5) MOVQ BP, 640(SP) 0x0031 00049 (main.go:5) LEAQ 640(SP), BP 0x0039 00057 (main.go:5) PCDATA $0, $-2 0x0039 00057 (main.go:5) PCDATA $1, $-2 0x0039 00057 (main.go:5) FUNCDATA $0, gclocals·ad6397d3d33bbb6a31b1320349e23274(SB) 0x0039 00057 (main.go:5) FUNCDATA $1, gclocals·1bbf1965a34fa71a63e073b1cf2d752a(SB) 0x0039 00057 (main.go:5) FUNCDATA $2, gclocals·658035074399f748be6dd39603d5113c(SB) 0x0039 00057 (main.go:5) FUNCDATA $3, \"\".main.stkobj(SB) 0x0039 00057 (main.go:6) PCDATA $0, $0 0x0039 00057 (main.go:6) PCDATA $1, $0 0x0039 00057 (main.go:6) CALL runtime.makemap_small(SB) 0x003e 00062 (main.go:6) PCDATA $0, $1 0x003e 00062 (main.go:6) MOVQ (SP), AX 0x0042 00066 (main.go:6) MOVQ AX, \"\".m1+80(SP) 0x0047 00071 (main.go:7) PCDATA $0, $0 0x0047 00071 (main.go:7) PCDATA $1, $1 0x0047 00071 (main.go:7) MOVQ AX, \"\"..autotmp_10+200(SP) 0x004f 00079 (main.go:7) PCDATA $1, $2 0x004f 00079 (main.go:7) XORPS X0, X0 0x0052 00082 (main.go:7) MOVUPS X0, \"\"..autotmp_9+272(SP) 0x005a 00090 (main.go:7) PCDATA $0, $1 0x005a 00090 (main.go:7) PCDATA $1, $1 0x005a 00090 (main.go:7) LEAQ \"\"..autotmp_9+272(SP), AX 0x0062 00098 (main.go:7) MOVQ AX, \"\"..autotmp_15+192(SP) 0x006a 00106 (main.go:7) TESTB AL, (AX) 0x006c 00108 (main.go:7) PCDATA $0, $2 0x006c 00108 (main.go:7) PCDATA $1, $0 0x006c 00108 (main.go:7) MOVQ \"\"..autotmp_10+200(SP), CX 0x0074 00116 (main.go:7) PCDATA $0, $3 0x0074 00116 (main.go:7) LEAQ type.map[string]string(SB), DX 0x007b 00123 (main.go:7) PCDATA $0, $2 0x007b 00123 (main.go:7) MOVQ DX, \"\"..autotmp_9+272(SP) 0x0083 00131 (main.go:7) PCDATA $0, $1 0x0083 00131 (main.go:7) MOVQ CX, \"\"..autotmp_9+280(SP) 0x008b 00139 (main.go:7) TESTB AL, (AX) 0x008d 00141 (main.go:7) JMP 143 0x008f 00143 (main.go:7) MOVQ AX, \"\"..autotmp_14+520(SP) 0x0097 00151 (main.go:7) MOVQ $1, \"\"..autotmp_14+528(SP) 0x00a3 00163 (main.go:7) MOVQ $1, \"\"..autotmp_14+536(SP) 0x00af 00175 (main.go:7) PCDATA $0, $0 0x00af 00175 (main.go:7) MOVQ AX, (SP) 0x00b3 00179 (main.go:7) MOVQ $1, 8(SP) 0x00bc 00188 (main.go:7) MOVQ $1, 16(SP) 0x00c5 00197 (main.go:7) CALL fmt.Println(SB) 0x00ca 00202 (main.go:8) CALL runtime.makemap_small(SB) 0x00cf 00207 (main.go:8) PCDATA $0, $1 0x00cf 00207 (main.go:8) MOVQ (SP), AX 0x00d3 00211 (main.go:8) MOVQ AX, \"\".m2+72(SP) 0x00d8 00216 (main.go:9) PCDATA $0, $0 0x00d8 00216 (main.go:9) PCDATA $1, $1 0x00d8 00216 (main.go:9) MOVQ AX, \"\"..autotmp_10+200(SP) 0x00e0 00224 (main.go:9) PCDATA $1, $2 0x00e0 00224 (main.go:9) XORPS X0, X0 0x00e3 00227 (main.go:9) MOVUPS X0, \"\"..autotmp_9+272(SP) 0x00eb 00235 (main.go:9) PCDATA $0, $1 0x00eb 00235 (main.go:9) PCDATA $1, $1 0x00eb 00235 (main.go:9) LEAQ \"\"..autotmp_9+272(SP), AX 0x00f3 00243 (main.go:9) MOVQ AX, \"\"..autotmp_17+184(SP) 0x00fb 00251 (main.go:9) TESTB AL, (AX) 0x00fd 00253 (main.go:9) PCDATA $0,","date":"2020-11-25","objectID":"/zh-cn/2020/11/25/go-sourcecode-map-first/:3:0","tags":["map","源码","golang"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"go的map对应的结构体hmap go的map的基础结构体是hmap,在runtime/map.go中， // A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler's definition. // map存储的键值对个数 count int // # live cells == size of map. Must be first (used by len() builtin) // 表示map的一些标志位 flags uint8 // map的桶的2的对数就是B值 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) // 溢出桶个数，是个近似数，不完全相等 noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details // hash种子 hash0 uint32 // hash seed // 桶，真正存数据的地方，2^B个桶 buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. // 保存一些即将迁移的桶 oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing // 从oldbuckets迁移到新的buckets的进度 nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) // 当key不是指针类型的数据的时候，里面会存溢出桶，这样会避免go的扫描 extra *mapextra // optional fields } 既然是map结构体，为何注释说是一个header呢？这是因为buckets和oldbuckets这2个字段并没有真正存取数据，只是存了一个指针，指向存取buckets的地址，故我们在使用过程中拷贝hmap的时候，并没有真正拷贝map的数据，只是拷贝了hmap这个结构体的一些数据。 在看看hmap的字段mapextra: // mapextra holds fields that are not present on all maps. type mapextra struct { // If both key and elem do not contain pointers and are inline, then we mark bucket // 如果key和value都不包括指针并且内敛，然后我们就标记bucket没有指针 // type as containing no pointers. This avoids scanning such maps. // 这样会避免gc扫描 // However, bmap.overflow is a pointer. In order to keep overflow buckets // 但是，虽然key和value不包括指针，但是逸出桶却是个指针，为了让逸出桶一直 // alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow. // 存在，所以就把逸出桶和需要迁移的逸出桶的指针存到hamp的extra字段里面 // overflow and oldoverflow are only used if key and elem do not contain pointers. // 如果key和elme包含指针，overflow和oldoverflow就不会被使用了 // overflow contains overflow buckets for hmap.buckets. // oldoverflow contains overflow buckets for hmap.oldbuckets. // The indirection allows to store a pointer to the slice in hiter. overflow *[]*bmap oldoverflow *[]*bmap // nextOverflow holds a pointer to a free overflow bucket. nextOverflow *bmap } 如mapextra结构体为啥说有些字段并不会在所有map里面全部都有呢？mapextra是一个为了优化bucket而设计的，当key或value是指针的时候，此时overflow和oldoverflow就不会被使用，只有nextOverflow会被使用，该字段保存了预先申请的逸出桶，在没有发生扩容的时候，而一个桶或者说bmap的8个tophash都被使用完了，那么就要考虑使用逸出桶。 当key和value都没有指针的时候bucket的bmap的_type的ptrdata就是0，意味着该结构体是没有指针的，申请bmap内存的时候，会申请一个没有指针的span，这样会避免gc扫描该内存，会提高效率，但是bmap的最后一个内存块是确确实实存放指针的，所以用uintptr存储着该map的逸出桶的地址，但是由于没有指向下一个逸出桶，可能会被gc回收掉，所以就需要overflow存取指向该逸出桶的指针避免被gc回收掉。 overflow和oldoverflow的用处差不多，只是oldoverflow为了迁移使用，后面的系列会详说。 ","date":"2020-11-25","objectID":"/zh-cn/2020/11/25/go-sourcecode-map-first/:4:0","tags":["map","源码","golang"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"bucket的结构体bmap bmap就是真正存数据的结构体了,bmap在源码中定义十分简单： // A bucket for a Go map. type bmap struct { // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] \u003c minTopHash, // tophash[0] is a bucket evacuation state instead. tophash [bucketCnt]uint8 // Followed by bucketCnt keys and then bucketCnt elems. // NOTE: packing all the keys together and then all the elems together makes the // code a bit more complicated than alternating key/elem/key/elem/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer. } 但其实真正的在内存中分配的结构体是这样的： // A bucket for a Go map. type bmap struct { // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] \u003c minTopHash, // tophash[0] is a bucket evacuation state instead. tophash [bucketCnt]uint8 keys [bucketCnt]string // 由于我举例的key是string，故我这里写string values [bucketCnt]string // 由于上面我的例子的value的类型是string，故这里也是string pointer unsafe.pointer // 由于key和value都是指针，所以这里是一个指针 // Followed by bucketCnt keys and then bucketCnt elems. // NOTE: packing all the keys together and then all the elems together makes the // code a bit more complicated than alternating key/elem/key/elem/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer. } 隐藏的字段在map源码中都是靠地址偏移来得到，tophash我们能轻易找到位置，但是如何找到keys、values和pointer呢？ 在map中是这么做的： dataOffset = unsafe.Offsetof(struct { b bmap v int64 }{}.v) 在64位机器上，需要对齐8个字节，这里int64正好也是8个字节，所以恰好解决内存对齐的问题，找到v的起始地址也就是values的起始地址: dataOffset+bucketCnt*2*sys.PtrSize // string16个字节，相当于2个指针，bucketCnt等于8 pointer的起始地址 dataOffset+bucketCnt*2*sys.PtrSize+sys.PtrSize tophash存的是key的hash高8位，为了方便查找key，为什么keys和values分别存在一堆呢？不是k|v|k|v这种呢？由于key和value的变量类型可能不一样，对齐系数不一致，可能导致内存不紧凑而浪费内存，所以把8个keys存到一堆，8个values存到一堆，然后最后在pointer之前对齐就可以了。所以此时也能算出来整个bmap的大小: bucketCnt*(uint8的字节为1)+bucketCnt*(string的字节16)+bucketCnt*(string的字节16)+指针大小8字节 = 272 在真正调试的时候如查看bucket里面的具体的key和value呢？这里给大家展示一个小技巧，如果大家有其他方法，可以留言讨论： type dmap struct { tophash [bucketCnt]uint8 debugKeys [bucketCnt]string debugElems [bucketCnt]string //debugOverflows unsafe.Pointer debugOverflows uintptr } 这是我定义的调试结构体，将该代码和bmap的结构体放到一堆，当你获取到bmap桶的地址的时候，就可以如下转换，就可以查看bmap的具体值了： b0 := (*dmap)(add(buckets, uintptr(0)*uintptr(t.bucketsize))) println(b0.debugOverflows) buckets假设是桶数组的起始地址，加上bucketsize就会得到第二个桶的起始地址，然后直接转型为*dmap,最后你可以可以打印出来你想查看的真实的值了。 ","date":"2020-11-25","objectID":"/zh-cn/2020/11/25/go-sourcecode-map-first/:5:0","tags":["map","源码","golang"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"map的整体结构 如果申请内存桶的时候又多余的溢出桶，那么mapextra的nextOverflow就会指向[]bmap其中的某块桶的地址，地址后之后的桶都是溢出桶。在一个桶装不下的时候，会去溢出桶拿桶然后bmap的overflow指向溢出桶。 ","date":"2020-11-25","objectID":"/zh-cn/2020/11/25/go-sourcecode-map-first/:6:0","tags":["map","源码","golang"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"总结 上面大概介绍了map的数据结构，后面系列map的具体代码分析，包括增、删、改、查、扩容等都会分篇细解，如有不足之处，请共同讨论学习。 ","date":"2020-11-25","objectID":"/zh-cn/2020/11/25/go-sourcecode-map-first/:7:0","tags":["map","源码","golang"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/2020/11/25/go-sourcecode-map-first/"},{"categories":["Hugo"],"content":"本文介绍如何使 Hugo 博客在 GitHub 自动部署","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"一、前言 使用 Hugo 有一些时间了，把内容上传到 GitHub Pages，从一开始的手动操作，到脚本操作，终于来到了自动化部署。 部署的流程： 本地通过 Hugo 命令创建文件，编写博客，编写好后把改变的内容上传到 GitHub 博客源文件仓库。通过 GitHub Action 自动触发脚本构建，然后把静态文件通过 GitHub Deploy 到博客仓库。 ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:1:0","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"二、具体步骤 ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:2:0","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.1 创建两个仓库 创建博客源仓库 创建博客静态资源仓库 ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:2:1","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.2 创建 SSH 需要生成一对 SSH Key，生成的 Public Key 和 Private Key 都会用到。 ssh-keygen -t rsa -b 4096 -C \"ironcity.hz@gmail.com\" Generating public/private rsa key pair. Enter file in which to save the key (/Users/tc/.ssh/id_rsa): 输入你需要指定的文件，比如 /Users/tc/.ssh/id_rsa_hugo_deploy 只是为了防止覆盖之前创建的默认文件 ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:2:2","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.2 配置博客静态资源仓库的 Deploy Keys 添加公钥到 funnycode-org.github.io 仓库的 Deploy Keys 添加后 ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:2:3","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.3 配置博客源内容仓库的 Secrets 添加私钥到 blog 仓库的 Secrets 添加后 注意这个 secrets 的名称 ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:2:4","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.4 编写博客 克隆 blog 项目到本地 # 选取一个目录 cd ~/Desktop/ # 克隆 source 仓库 git clone git@github.com:funnycode-org/blog.git # 进入仓库 cd blog 创建 hugo 博客 # 创建博客，多语言模式 hugo new /posts/[blog-name]/index.zh-cn.md # 运行预览效果 hugo serve -D 如果没有什么问题就可以准备提交代码了 git add . git commit -m \"update commit\" git push -u origin master ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:2:5","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.5 GitHub Actions 说明 Actions 内容： name: Deploy Hugo Site to Github Pages on Master Branch on: push: branches: - master jobs: build-deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: '0.76.0' # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: funnycode-org/funnycode-org.github.io # remote branch publish_dir: \"./docs\" cname: blog.funnycode.org.cn keep_files: false # remove existing files publish_branch: docs # deploying branch commit_message: ${{ github.event.head_commit.message }} 注意点： publish_dir 指定发布的目录，./docs 指 blog 项目下的 docs 目录下的内容会被发布 publish_branch 发布到 funnycode-org.github.io 项目的 docs 分支 secrets.ACTIONS_DEPLOY_KEY 的 ACTIONS_DEPLOY_KEY 则是上面设置 Private Key 的变量名 cname 必须要配置好，和下文提到的 Setting 里面配置图对应 ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:2:6","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.7 funnycode-org.github.io 配置 配置 Setting 验证访问 输入 https://blog.funnycode.org.cn，效果： ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:2:7","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"三、参考 https://github.com/peaceiris/actions-hugo https://zhuanlan.zhihu.com/p/109057290 https://github.com/peaceiris/actions-gh-pages ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:3:0","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":[],"content":"一、题目 ","date":"2020-01-30","objectID":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/:1:0","tags":[],"title":"LeetCode703题笔记","uri":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/"},{"categories":[],"content":"1.1 题目说明 设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。 请实现 KthLargest 类： KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。 int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。 示例： 输入： [\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] 输出： [null, 4, 5, 5, 8, 8] 解释： KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.add(5); // return 5 kthLargest.add(10); // return 5 kthLargest.add(9); // return 8 kthLargest.add(4); // return 8 1 \u003c= k \u003c= 104 0 \u003c= nums.length \u003c= 104 -104 \u003c= nums[i] \u003c= 104 -104 \u003c= val \u003c= 104 最多调用 add 方法 104 次 题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素 leetcode地址 ","date":"2020-01-30","objectID":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/:1:1","tags":[],"title":"LeetCode703题笔记","uri":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/"},{"categories":[],"content":"1.2 审题 优先级队列的实现方式： 堆（二叉堆，二项式堆，斐波拉契堆） 二叉搜索树 堆的比较： （严格）斐波拉契堆是性能比较好 ","date":"2020-01-30","objectID":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/:1:2","tags":[],"title":"LeetCode703题笔记","uri":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/"},{"categories":[],"content":"二、题解 ","date":"2020-01-30","objectID":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/:2:0","tags":[],"title":"LeetCode703题笔记","uri":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/"},{"categories":[],"content":"2.1 排序大法 排序的思路： 先找到当前插入元素的位置 如果K大小数组没满，那么比当前值大的值往后 如果K大小数组满了，那么比当前值大的值之前往前移动，即挤掉最小值 代码： type KthLargest_Sort struct { // k 个元素的数组 array []int size int full bool } func Constructor_Sort(k int, nums []int) KthLargest_Sort { re := KthLargest_Sort{array: []int{}, size: k} if len(nums) == 0 { return re } // 排序 sort.Ints(nums) // 符合要求的元素设置到 array s := len(nums) - k if s \u003c 0 { s = 0 } for i := s; i \u003c len(nums); i++ { re.array = append(re.array, nums[i]) } re.setFull() return re } func (this *KthLargest_Sort) Add(val int) int { // 没满 if !this.full { this.array = append(this.array, val) sort.Ints(this.array) this.setFull() return this.array[0] } // 满了，就考虑是否替换 // 如果最小值都比新值大或等于新值，那么不用处理 min := this.array[0] if min \u003e= val { return this.array[0] } // 如果是最大值，就直接移动，省去遍历 max := this.array[len(this.array)-1] if val \u003e max { this.array = this.array[1:] this.array = append(this.array, val) return this.array[0] } big := -1 for i, v := range this.array { if v \u003e= val { big = i break } } // 前移 for i := 0; i \u003c big-1; i++ { this.array[i], this.array[i+1] = this.array[i+1], this.array[i+2] } this.array[big-1] = val return this.array[0] } func (this *KthLargest_Sort) setFull() { if len(this.array) \u003e= this.size { this.full = true } } 时间复杂度：忽略各种分支，关心移动部分的代码 ，$\\frac{n*k}{2}$ 成绩： 执行用时：92 ms, 在所有 Go 提交中击败了19.61%的用户 内存消耗：8.4 MB, 在所有 Go 提交中击败了8.61%的用户 ","date":"2020-01-30","objectID":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/:2:1","tags":[],"title":"LeetCode703题笔记","uri":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/"},{"categories":[],"content":"2.2 排序大法（简化非有效版本） 代码： type KthLargest_Sort struct { // k 个元素的数组 array []int size int } func Constructor_Sort(k int, nums []int) KthLargest_Sort { re := KthLargest_Sort{array: []int{}, size: k} if len(nums) == 0 { return re } // 排序 sort.Ints(nums) // 符合要求的元素设置到 array s := len(nums) - k if s \u003c 0 { s = 0 } for i := s; i \u003c len(nums); i++ { re.array = append(re.array, nums[i]) } return re } func (this *KthLargest_Sort) Add(val int) int { // 把新元素加到缓存的数组中，然后对数组元素进行排序 this.array = append(this.array, val) sort.Ints(this.array) // 如果新元素加上后超过了K个大小（即K+1），那么把第一个（最小值）去掉 if len(this.array) \u003e this.size { this.array = this.array[1:] } return this.array[0] } 时间复杂度：每一次都是一次快排，一共加了 n 次，那么是 $n * k\\log{k}$ 结果： ","date":"2020-01-30","objectID":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/:2:2","tags":[],"title":"LeetCode703题笔记","uri":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/"},{"categories":[],"content":"2.3 排序大法（第一种思路重写） type KthLargest_SortPro struct { // k 个元素的数组 array []int // 当前元素个数 size int } func Constructor_SortPro(k int, nums []int) KthLargest_SortPro { re := KthLargest_SortPro{array: []int{}, size: k} if len(nums) == 0 { return re } for _, v := range nums { re.Add(v) } return re } func (this *KthLargest_SortPro) Add(val int) int { // 未满 if len(this.array) \u003c this.size { // 找到位置，第一个位置最小值不特意取出来比较了，因为循环第一个就匹配到了 p := -1 for i := 0; i \u003c len(this.array); i++ { if this.array[i] \u003e= val { p = i break } } // val 是最大值 if p == -1 { this.array = append(this.array, val) } else { max := this.array[len(this.array)-1] for i := len(this.array) - 2; i \u003e= p; i-- { this.array[i+1] = this.array[i] } this.array = append(this.array, max) this.array[p] = val } } else { p := -1 for i := 0; i \u003c len(this.array); i++ { if this.array[i] \u003e= val { p = i break } } // val 是最大值，这个地方可以直接拿最大值比较 if p == -1 { this.array = this.array[1:] this.array = append(this.array, val) } else if p == 0 { } else { for i := 0; i \u003c p-1; i++ { this.array[i] = this.array[i+1] } this.array[p-1] = val } } return this.array[0] } 时间复杂度和上面的应该一样，反正我已经算的晕了 成绩： 执行用时：96 ms, 在所有 Go 提交中击败了19.48%的用户 内存消耗：8.3 MB, 在所有 Go 提交中击败了28.29%的用户 这种代码的写法实际上在 go 里面是不符合规范的，go 是要尽可能避免 if - else 的嵌套，采用 if ! condition - return 的模式。 ","date":"2020-01-30","objectID":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/:2:3","tags":[],"title":"LeetCode703题笔记","uri":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/"},{"categories":[],"content":"2.4 小顶堆实现 正规军出马了 代码： // 最小堆实现 type KthLargest struct { heap *IntHeap size int } func Constructor(k int, nums []int) KthLargest { ih := new(IntHeap) heap.Init(ih) for _, v := range nums { if ih.Len() \u003c k { heap.Push(ih, v) } else { _, min := ih.Top() if v \u003e min { heap.Pop(ih) heap.Push(ih, v) } } } return KthLargest{heap: ih, size: k} } func (this *KthLargest) Add(val int) int { b, min := this.heap.Top() if !b { heap.Push(this.heap, val) return val } if this.heap.Len() \u003c this.size{ heap.Push(this.heap, val) _, min = this.heap.Top() return min } if val \u003e min { heap.Pop(this.heap) heap.Push(this.heap, val) _, min = this.heap.Top() } return min } // 这部分代码来自 golang SDK 的 heap 包 // 主要看 Less 的比较逻辑，这里 h[i] 小于 h[j] 的条件是小顶堆 type IntHeap []int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] \u003c h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x interface{}) { // Push and Pop use pointer receivers because they modify the slice's length, // not just its contents. *h = append(*h, x.(int)) } func (h *IntHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x } func (h *IntHeap) Top() (bool, int) { if h.Len() == 0 { return false, 0 } old := *h return true, old[0] } 时间复杂度：$n\\log{k}$ ，比排序的好 K 倍（每一次排序都是 $\\log{k}$） 成绩： 执行用时：36 ms, 在所有 Go 提交中击败了70.13%的用户 内存消耗：8.3 MB, 在所有 Go 提交中击败了33.55%的用户 从成绩可以看出来，比排序的做法好很多，因为即使 n 个元素的加入都需要调整堆，每次调整 $\\log{k}$ 。 ","date":"2020-01-30","objectID":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/:2:4","tags":[],"title":"LeetCode703题笔记","uri":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/"},{"categories":[],"content":"2.5 小结 记住 TopK 问题可以用堆来解决 堆的话语言都已经有实现了，不建议自己手写了，go 和 java 的堆实现会在源码篇幅展开。 本章的代码连接 ","date":"2020-01-30","objectID":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/:2:5","tags":[],"title":"LeetCode703题笔记","uri":"/zh-cn/notes/leetcode703-kth-largest-element-in-a-stream/"},{"categories":[],"content":"一、题目 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode225-implement-stack-using-queues/:1:0","tags":[],"title":"LeetCode225题笔记","uri":"/zh-cn/notes/leetcode225-implement-stack-using-queues/"},{"categories":[],"content":"1.1 题目说明 使用队列实现栈的下列操作： push(x) – 元素 x 入栈 pop() – 移除栈顶元素 top() – 获取栈顶元素 empty() – 返回栈是否为空 注意: 你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。 leetcode地址 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode225-implement-stack-using-queues/:1:1","tags":[],"title":"LeetCode225题笔记","uri":"/zh-cn/notes/leetcode225-implement-stack-using-queues/"},{"categories":[],"content":"1.2 审题 栈 参考之前的笔记。 什么是队列？ 队列是一个 FIFO 先进先出的数据结构。 基本操作和栈类似，称为 出队和入队。 go 的队列？ 直接就用数组去表示。 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode225-implement-stack-using-queues/:1:2","tags":[],"title":"LeetCode225题笔记","uri":"/zh-cn/notes/leetcode225-implement-stack-using-queues/"},{"categories":[],"content":"二、题解 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode225-implement-stack-using-queues/:2:0","tags":[],"title":"LeetCode225题笔记","uri":"/zh-cn/notes/leetcode225-implement-stack-using-queues/"},{"categories":[],"content":"2.1 两个队列实现 操作图： 代码： type MyStack struct { q1 []int // 这里对应stack数据 q2 []int // 辅助的 } /** Initialize your data structure here. */ func Constructor() MyStack { return MyStack{ q1: []int{}, q2: []int{}, } } /** Push element x onto stack. */ func (this *MyStack) Push(x int) { this.q2 = append(this.q2, x) for i := 0; i \u003c len(this.q1); i++ { this.q2 = append(this.q2, this.q1[i]) } this.q1, this.q2 = this.q2, []int{} } /** Removes the element on top of the stack and returns that element. */ func (this *MyStack) Pop() int { r := this.Top() this.q1 = this.q1[1:] return r } /** Get the top element. */ func (this *MyStack) Top() int { return this.q1[0] } /** Returns whether the stack is empty. */ func (this *MyStack) Empty() bool { return len(this.q1) == 0 } 时间复杂度 – 入栈：$ O(n) $ 出栈 $ O(1) $ 空间复杂度 $ O(n) $ 成绩： 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 MB, 在所有 Go 提交中击败了68.06%的用户 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode225-implement-stack-using-queues/:2:1","tags":[],"title":"LeetCode225题笔记","uri":"/zh-cn/notes/leetcode225-implement-stack-using-queues/"},{"categories":[],"content":"2.2 一个队列实现 操作图： 代码： type MyStack struct { element []int } /** Initialize your data structure here. */ func Constructor() MyStack { return MyStack{ element: []int{}, } } /** Push element x onto stack. */ func (this *MyStack) Push(x int) { this.element = append(this.element, x) if len(this.element) \u003e 1 { // 拿出第一个，后面的往后移动 front := this.element[len(this.element)-1] for i := len(this.element) - 1; i \u003e 0; i-- { this.element[i] = this.element[i-1] } this.element[0] = front } } /** Removes the element on top of the stack and returns that element. */ func (this *MyStack) Pop() int { r := this.Top() this.element = this.element[1:] return r } /** Get the top element. */ func (this *MyStack) Top() int { return this.element[0] } /** Returns whether the stack is empty. */ func (this *MyStack) Empty() bool { return len(this.element) == 0 } 时间复杂度 – 入栈：$ O(n) $ 出栈 $ O(1) $ 空间复杂度 $ O(n) $，比双队列要省空间 成绩： 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 MB, 在所有 Go 提交中击败了100.00%的用户 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode225-implement-stack-using-queues/:2:2","tags":[],"title":"LeetCode225题笔记","uri":"/zh-cn/notes/leetcode225-implement-stack-using-queues/"},{"categories":[],"content":"2.3 发现 LeetCode 你不用队列也能通过 代码： type MyStack struct { element []int } /** Initialize your data structure here. */ func Constructor() MyStack { return MyStack{ element: []int{}, } } /** Push element x onto stack. */ func (this *MyStack) Push(x int) { this.element = append(this.element, x) } /** Removes the element on top of the stack and returns that element. */ func (this *MyStack) Pop() int { r := this.Top() this.element = this.element[:len(this.element)-1] return r } /** Get the top element. */ func (this *MyStack) Top() int { return this.element[len(this.element)-1] } /** Returns whether the stack is empty. */ func (this *MyStack) Empty() bool { if this.element != nil \u0026\u0026 len(this.element) \u003e 0 { return false } return true } 成绩： 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 MB, 在所有 Go 提交中击败了68.28%的用户 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode225-implement-stack-using-queues/:2:3","tags":[],"title":"LeetCode225题笔记","uri":"/zh-cn/notes/leetcode225-implement-stack-using-queues/"},{"categories":[],"content":"2.2 小结 题目和232比较类似，未想到实际项目场景 建议看看就好 本章的代码连接 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode225-implement-stack-using-queues/:2:4","tags":[],"title":"LeetCode225题笔记","uri":"/zh-cn/notes/leetcode225-implement-stack-using-queues/"},{"categories":[],"content":"一、题目 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/:1:0","tags":[],"title":"LeetCode232题笔记","uri":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/"},{"categories":[],"content":"1.1 题目说明 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 进阶： 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。 示例： 输入： [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] 输出： [null, null, null, 1, 1, false] 解释： MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false 提示： 1 \u003c= x \u003c= 9 最多调用 100 次 push、pop、peek 和 empty 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作） leetcode地址 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/:1:1","tags":[],"title":"LeetCode232题笔记","uri":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/"},{"categories":[],"content":"1.2 审题 概率可以查看之前的笔记 队列 栈 两个栈是关键，栈是先入后出，队列是先入先出，那么使用负负得正的思路去做，把元素在两个栈之间捣腾，图解如下： 使用栈来实现的队列，在出栈的时候如果发现输出栈的栈是空，那么需要有一步 move 的操作来把输入栈的内容出栈并向输出栈入栈。 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/:1:2","tags":[],"title":"LeetCode232题笔记","uri":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/"},{"categories":[],"content":"2、题解 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/:2:0","tags":[],"title":"LeetCode232题笔记","uri":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/"},{"categories":[],"content":"2.1 实现 代码： type MyQueue struct { in []int // 输入栈 out []int // 输出栈 } /** Initialize your data structure here. */ func Constructor() MyQueue { return MyQueue{ in: []int{}, out: []int{}, } } /** Push element x to the back of queue. */ func (this *MyQueue) Push(x int) { this.in = append(this.in, x) } /** Removes the element from in front of queue and returns that element. */ func (this *MyQueue) Pop() int { r := this.Peek() this.out = this.out[:len(this.out)-1] return r } /** Get the front element. */ func (this *MyQueue) Peek() int { if len(this.out) \u003e 0 { return this.out[len(this.out)-1] } if len(this.out) == 0 \u0026\u0026 len(this.in) \u003e 0 { this.move() } return this.Peek() } /** Returns whether the queue is empty. */ func (this *MyQueue) Empty() bool { return len(this.in)+len(this.out) == 0 } // 相当于从 in 出栈，到 out 入栈 func (this *MyQueue) move() { for i := len(this.in) - 1; i \u003e= 0; i-- { this.out = append(this.out, this.in[i]) } this.in = []int{} } 时间复杂度 – 入队：$ O(1) $ 出队：$ O(1) $，均摊的时间复杂度（最坏情况下的操作一旦发生了一次，那么在未来很长一段时间都不会再次发生，这样就会均摊每次操作的代价），简单的讲一个元素经历了（入栈，出栈，入栈，出栈），所以是稳定的时间复杂度。 空间复杂度 – 入队：$ O(n) $ 出队：$ O(1) $ 成绩： 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 MB, 在所有 Go 提交中击败了91.91%的用户 另一个写法： 其它的一种做法是在入队列的时候先捣腾好顺序，出队的时候就直接出就行了，这个会明显增加捣腾的次数，比如： 输入 1，2，3，4。s1，s2 分别是2个stack，比较简单也不画图了，直接看下面的抽象演变过程： 1|NULL ==》NULL|1 – 2|1 – 1/2|NULL ==\u003e NULL|2/1 – 3|2/1 – 1/2/3|NULL ==\u003e NULL|3/2/1 – 4|3/2/1 – 1/2/3/4|NULL step1 1入队s1 step2 1出队s1 1入队s2 2入队s1 1出队s2 1 入队s1 step3 1出队s1 1入队s2 2出队s1 2入队s2 3入队s1 2出队s2 2入队s1 1出队s2 1入队s1 step4 1出队s1 1入队s2 2出队s1 2入队s2 3出队s1 3入队s2 4入队s1 3出队s2 3入队s1 2出队s2 2入队s1 1出队s2 1入队s1 n越大，次数就越多，2n的移动数，所以时间复杂度会是 $ O(n) $。 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/:2:1","tags":[],"title":"LeetCode232题笔记","uri":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/"},{"categories":[],"content":"2.2 小结 题目比较简单，未想到实际项目场景 建议看看就好 本章的代码连接 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/:2:2","tags":[],"title":"LeetCode232题笔记","uri":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/"},{"categories":[],"content":"一、题目 ","date":"2020-01-23","objectID":"/zh-cn/notes/leetcode20-valid-parentheses/:1:0","tags":[],"title":"LeetCode20题笔记","uri":"/zh-cn/notes/leetcode20-valid-parentheses/"},{"categories":[],"content":"1.1 题目说明 给定一个只包括 ‘('，')'，'{'，'}'，'['，']’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: \"()\" 输出: true 示例 2: 输入: \"()[]{}\" 输出: true 示例 3: 输入: \"(]\" 输出: false 示例 4: 输入: \"([)]\" 输出: false 示例 5: 输入: \"{[]}\" 输出: true leetcode地址 ","date":"2020-01-23","objectID":"/zh-cn/notes/leetcode20-valid-parentheses/:1:1","tags":[],"title":"LeetCode20题笔记","uri":"/zh-cn/notes/leetcode20-valid-parentheses/"},{"categories":[],"content":"1.2 题目知识点介绍 这道题目主要是考核堆栈这个数据结构，它是一个先进先出、操作受限的线性表，也称为 栈。 栈的两种基本的操作 入栈 push： 往栈中最顶端插入数据 出栈 pop： 从栈中删除最顶端的数据 栈的实现方式 数组实现，称为顺序栈 链表实现，称为链式栈 手动实现一个栈 ","date":"2020-01-23","objectID":"/zh-cn/notes/leetcode20-valid-parentheses/:1:2","tags":[],"title":"LeetCode20题笔记","uri":"/zh-cn/notes/leetcode20-valid-parentheses/"},{"categories":[],"content":"二、题解 ","date":"2020-01-23","objectID":"/zh-cn/notes/leetcode20-valid-parentheses/:2:0","tags":[],"title":"LeetCode20题笔记","uri":"/zh-cn/notes/leetcode20-valid-parentheses/"},{"categories":[],"content":"2.1 栈实现 代码： func isValid(s string) bool { var stack []byte pairs := map[byte]byte{ ')': '(', ']': '[', '}': '{', } for i := range s { if pairs[s[i]] \u003e 0 { // 这里如果没匹配到，是 byte 默认值 0 if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] { // 栈顶 Top() 匹配期望值 return false } stack = stack[:len(stack)-1] // 移除栈顶 Pop() } else { stack = append(stack, s[i]) } } return len(stack) == 0 } 时间复杂度 $ O(n) $ n 是字符串长度 空间复杂度 $ O(n+6) $ 因为这个题目中就 6 种扩展，空间就和栈中存放的数据有关，也就是和字符串长度有关 小优化： func isValid(s string) bool { if len(s)\u00261 == 1 { return false } var stack []byte pairs := map[byte]byte{ ')': '(', ']': '[', '}': '{', } for i := range s { if pairs[s[i]] \u003e 0 { // 这里如果没匹配到，是 byte 默认值 0 if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] { // 栈顶 Top() 匹配期望值 return false } stack = stack[:len(stack)-1] // 移除栈顶 Pop() } else { stack = append(stack, s[i]) } } return len(stack) == 0 } 如果是奇数肯定不可能是 true 成绩： 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 MB, 在所有 Go 提交中击败了91.93%的用户 栈的操作图： ","date":"2020-01-23","objectID":"/zh-cn/notes/leetcode20-valid-parentheses/:2:1","tags":[],"title":"LeetCode20题笔记","uri":"/zh-cn/notes/leetcode20-valid-parentheses/"},{"categories":[],"content":"2.2 非栈实现 代码： func isValid(s string) bool { var l int for ok := true; ok; ok = l != len(s) { l = len(s) s = strings.ReplaceAll(strings.ReplaceAll(strings.ReplaceAll(s, \"()\", \"\"), \"{}\", \"\"), \"[]\", \"\") } return len(s) == 0 } 平均时间复杂度是 $ O^2/2 $，字符串替换是 n，for 循环是 n，所以是 n 平方 虽然代码很精简，但是时间和空间复杂度的表现都不是很好 成绩： 执行用时：8 ms, 在所有 Go 提交中击败了7.18%的用户 内存消耗：7.1 MB, 在所有 Go 提交中击败了5.07%的用户 ","date":"2020-01-23","objectID":"/zh-cn/notes/leetcode20-valid-parentheses/:2:2","tags":[],"title":"LeetCode20题笔记","uri":"/zh-cn/notes/leetcode20-valid-parentheses/"},{"categories":[],"content":"2.3 小结 强烈建议使用栈来实现 栈的逻辑是：如果是左边括号就入栈，如果遇到右边括号就去查询栈顶元素，如果是与之匹配的左边括号的话就取出元素，否则就不匹配返回，执行到最后查看栈是否为空，空的话就是匹配的 记得对边界条件做处理，比如字符串长度是奇数的处理 空字符串也是满足的 本章的代码连接 ","date":"2020-01-23","objectID":"/zh-cn/notes/leetcode20-valid-parentheses/:2:3","tags":[],"title":"LeetCode20题笔记","uri":"/zh-cn/notes/leetcode20-valid-parentheses/"},{"categories":["设计模式"],"content":"本文介绍设计模式之模板方法模式","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"一、前言 Template Pattern 模板方法 来自 Wiki 百科的介绍： 模板方法模型是一种行为设计模型。模板方法是一个定义在父类别的方法，在模板方法中会呼叫多个定义在父类别的其他方法，而这些方法有可能只是抽象方法并没有实作，模板方法仅决定这些抽象方法的执行顺序，这些抽象方法的实作由子类别负责，并且子类别不允许覆写模板方法。 模板方法是属于设计模式的行为型模式 模板方法模式按照我的白话文理解： 首先定一个“抽象类”，它有一个模板方法A，定义可能需要子类实现的方法B，C，D…，然后在A方法里面编排好了B，C，D等的位置，当实现类调用A的时候，会调用各自实现的B，C，D方法（某些方法有默认实现，子类可以不实现），从而在一样的大流程里面进行不一样的操作。 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:1:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"二、简单实例 故事背景 阳光明媚的一天，玩码部落来了一群腿长一米八的MM，它们来自台湾，杭州及北京，她们将介绍各自家乡是如何准备丰富的晚餐的。 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:2:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"2.1 Java版本 2.1.1 定义接口 public interface Dinner { /** * 晚餐 */ void doDinner(); } 定义一个接口，就一个无参的 void 方法。 2.1.2 定义抽象方法 public abstract class AbstractDinner implements Dinner { protected String name; public AbstractDinner(String name) { this.name = name; } private void eat() { System.out.printf(\"%sMM说：开吃喽\", name).println(); } protected boolean foodEnough() { return true; } protected void doShopping() { System.out.println(\"门口小贩买菜\"); } protected abstract void beforeCooking(); protected abstract String doCooking(); protected abstract void afterCooking(); @Override public void doDinner() { if (!foodEnough()) { doShopping(); } beforeCooking(); System.out.println(doCooking()); afterCooking(); eat(); } } 定义 AbstractDinner 实现接口，它自身有五个方法，默认实现的 foodEnough 和 doShopping，以及抽象方法 beforeCooking、doCooking 和 afterCooking。 doDinner 编排了这些方法的流程或者说定义了各阶段的步骤。 2.1.3 定义实现类 public class BeijingDinner extends AbstractDinner { public BeijingDinner(String name) { super(name); } @Override protected void beforeCooking() { System.out.printf(\"%sMM 在洗菜切菜\", name).println(); } @Override protected String doCooking() { return name + \"MM 在做\" + name + \"菜\"; } @Override protected void afterCooking() { System.out.printf(\"%sMM 让你去品尝\", name).println(); } } public class TaiwanDinner extends AbstractDinner { public TaiwanDinner(String name) { super(name); } @Override protected boolean foodEnough() { // 每次都买食物 return false; } @Override protected void doShopping() { System.out.println(\"生鲜超市购买，一定要买茶叶蛋\"); } @Override protected void beforeCooking() { System.out.printf(\"%sMM 在洗菜切菜\", name).println(); } @Override protected String doCooking() { return name + \"MM 在做\" + name + \"菜\"; } @Override protected void afterCooking() { System.out.printf(\"%sMM 让你去品尝\", name).println(); } } public class HangzhouDinner extends AbstractDinner { public HangzhouDinner(String name) { super(name); } @Override protected boolean foodEnough() { // 每次都买食物 return false; } @Override protected void beforeCooking() { System.out.printf(\"%sMM 在洗菜切菜\", name).println(); } @Override protected String doCooking() { return name + \"MM 在做\" + name + \"菜\"; } @Override protected void afterCooking() { System.out.printf(\"%sMM 让你去品尝\", name).println(); } } 定义了三个实现类，都实现了3个抽象方法。另外 TaiwanDinner 重写了另外两个方法，HangzhouDinner 只重写了 foodEnough。 2.1.4 运行例子 代码： public class DinnerDemo { public static void main(String[] args) { System.out.println(\"---准备台湾餐---\"); Dinner dinner1 = new TaiwanDinner(); dinner1.doDinner(); System.out.println(\"---准备杭州餐---\"); Dinner dinner2 = new HangzhouDinner(); dinner2.doDinner(); System.out.println(\"---准备北京餐---\"); Dinner dinner3 = new BeijingDinner(); dinner3.doDinner(); } } 输出结果： ---准备台湾餐--- 生鲜超市购买，一定要买茶叶蛋 台湾MM 在洗菜切菜 台湾MM 在做台湾菜 台湾MM 让你去品尝 台湾MM说：开吃喽 ---准备杭州餐--- 门口小贩买菜 杭州MM 在洗菜切菜 杭州MM 在做杭州菜 杭州MM 让你去品尝 杭州MM说：开吃喽 ---准备北京餐--- 北京MM 在洗菜切菜 北京MM 在做北京菜 北京MM 让你去品尝 北京MM说：开吃喽 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:2:1","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"2.2 Golang 版本 声明下：在 golang 中，由于不存在抽象类和真正的继承，所以只能通过一个基础类来充当抽象类，子类通过组合基础类来实现通用方法的继承。 2.2.1 定义接口 type Dinner interface { DoDinner() } 2.2.2 定义抽象类 type AbstractCooking struct { foodEnough func() bool doShopping func() beforeCooking func() doCooking func() string afterCooking func() Name string } func (d *AbstractCooking) DoDinner() { if !d.foodEnough() { d.doShopping() } d.beforeCooking() fmt.Println(d.doCooking()) d.afterCooking() d.eat() } func (d *AbstractCooking) eat() { fmt.Println(fmt.Sprintf(\"%sMM说：开吃喽\", d.Name)) } 这里和 Java 不一样的地方是 go 的结构体可以拥有 func() 属性（也可以拥有接口属性）。 实现 Dinner 的方法 DoDinner , 编排了一系列的方法。 2.2.3 定义实现类 type HZDinner struct { AbstractCooking } func NewHZDinner(name string) *HZDinner { c := new(HZDinner) c.Name = name // 选择实现的 c.AbstractCooking.foodEnough = c.foodEnough c.AbstractCooking.doShopping = doShopping // 必须实现的 c.AbstractCooking.beforeCooking = c.beforeCooking c.AbstractCooking.doCooking = c.doCooking c.AbstractCooking.afterCooking = c.afterCooking return c } func (c *HZDinner) foodEnough() bool { return false } func (c *HZDinner) beforeCooking() { println(fmt.Printf(\"%sMM 在洗菜切菜\", c.Name)) } func (c *HZDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", c.Name, c.Name) } func (c *HZDinner) afterCooking() { println(fmt.Printf(\"%sMM 让你去品尝\", c.Name)) } type TWDinner struct { AbstractCooking } func NewTWDinner(name string) *TWDinner { c := new(TWDinner) c.Name = name // 选择实现的 c.AbstractCooking.foodEnough = c.foodEnough c.AbstractCooking.doShopping = c.doShopping // 必须实现的 c.AbstractCooking.beforeCooking = c.beforeCooking c.AbstractCooking.doCooking = c.doCooking c.AbstractCooking.afterCooking = c.afterCooking return c } func (c *TWDinner) foodEnough() bool { return false } func (c *TWDinner) doShopping() { fmt.Println(\"生鲜超市购买，一定要买茶叶蛋\") } func (c *TWDinner) beforeCooking() { println(fmt.Printf(\"%sMM 在洗菜切菜\", c.Name)) } func (c *TWDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", c.Name, c.Name) } func (c *TWDinner) afterCooking() { println(fmt.Printf(\"%sMM 让你去品尝\", c.Name)) } type BJDinner struct { AbstractCooking } func NewBJDinner(name string) *BJDinner { c := new(BJDinner) c.Name = name // 选择实现的 c.AbstractCooking.foodEnough = foodEnough c.AbstractCooking.doShopping = doShopping // 必须实现的 c.AbstractCooking.beforeCooking = c.beforeCooking c.AbstractCooking.doCooking = c.doCooking c.AbstractCooking.afterCooking = c.afterCooking return c } func (c *BJDinner) beforeCooking() { println(fmt.Printf(\"%sMM 在洗菜切菜\", c.Name)) } func (c *BJDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", c.Name, c.Name) } func (c *BJDinner) afterCooking() { println(fmt.Printf(\"%sMM 让你去品尝\", c.Name)) } 2.2.4 定义默认实现方法 func foodEnough() bool { return true } func doShopping() { fmt.Println(\"门口小贩买菜\") } 为什么有独立的默认方法，因为 struct 里面定义了 foodEnough() bool 和 doShopping() 两个方法，go 里面是不能重名的，因此不能再写属于 AbstractCooking 的方法。 func (d *AbstractCooking) foodEnough() bool { return true } 这个方法如何写了，去掉了 struct 的 foodEnough() bool，那么创建实现类的时候就没办法 c.AbstractCooking.foodEnough = c.foodEnough 进行 func() 赋值，从而 d.foodEnough() 会一直调用 AbstractCooking 下的 foodEnough()，实现类没办法自定义实现了。 2.2.5 运行例子 代码： func TestTemplate1(t *testing.T) { fmt.Println(\"---准备台湾餐---\") d1 := NewTWDinner(\"台湾\") d1.DoDinner() fmt.Println(\"---准备杭州餐---\") d2 := NewHZDinner(\"杭州\") d2.DoDinner() fmt.Println(\"---准备北京餐---\") d3 := NewBJDinner(\"北京\") d3.DoDinner() } 输出结果： ---准备台湾餐--- 生鲜超市购买，一定要买茶叶蛋 台湾MM 在洗菜切菜 台湾MM 在做台湾菜 台湾MM 让你去品尝 台湾MM说：开吃喽 ---准备杭州餐--- 门口小贩买菜 杭州MM 在洗菜切菜 杭州MM 在做杭州菜 杭州MM 让你去品尝 杭州MM说：开吃喽 ---准备北京餐--- 北京MM 在洗菜切菜 北京MM 在做北京菜 北京MM 让你去品尝 北京MM说：开吃喽 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:2:2","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"2.3 Golang版本2 上面例子是在 struct 中定义，相当于是抽象方法的意思，而这版本把那部分方法都定义到了接口。 2.3.1 定义接口 type Dinner2 interface { foodEnough() bool doShopping() beforeCooking() doCooking() string afterCooking() } 2.3.2 定义抽象类 type AbstractDinner struct { } func (AbstractDinner) foodEnough() bool { return true } func (AbstractDinner) doShopping() { fmt.Println(\"门口小贩买菜\") } func (AbstractDinner) beforeCooking() { } func (AbstractDinner) doCooking() string { return \"\" } func (AbstractDinner) afterCooking() { } 实现 Dinner2 接口，和下面等价 type AbstractDinner struct { Dinner2 } func (AbstractDinner) foodEnough() bool { return true } func (AbstractDinner) doShopping() { fmt.Println(\"门口小贩买菜\") } 2.3.3 定义实现类 type HangzhouDinner struct { AbstractDinner } func NewHangzhouDinner(name string) Dinner2 { return \u0026HangzhouDinner{ AbstractDinner{ Name: name, }, } } func (d *HangzhouDinner) foodEnough() bool { return false } func (d *HangzhouDinner) beforeCooking() { fmt.Println(fmt.Sprintf(\"%sMM 在洗菜切菜\", d.Name)) } func (d *HangzhouDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", d.Name, d.Name) } func (d *HangzhouDinner) afterCooking() { fmt.Println(fmt.Sprintf(\"%sMM 让你去品尝\", d.Name)) } type BeijingDinner struct { AbstractDinner } func NewBeijingDinner(name string) Dinner2 { return \u0026BeijingDinner{ AbstractDinner{ Name: name, }, } } func (d *BeijingDinner) beforeCooking() { fmt.Println(fmt.Sprintf(\"%sMM 在洗菜切菜\", d.Name)) } func (d *BeijingDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", d.Name, d.Name) } func (d *BeijingDinner) afterCooking() { fmt.Println(fmt.Sprintf(\"%sMM 让你去品尝\", d.Name)) } type TaiwanDinner struct { AbstractDinner } func NewTaiwanDinner(name string) Dinner2 { return \u0026TaiwanDinner{ AbstractDinner{ Name: name, }, } } func (d *TaiwanDinner) foodEnough() bool { return false } func (d *TaiwanDinner) doShopping() { fmt.Println(\"生鲜超市购买，一定要买茶叶蛋\") } func (d *TaiwanDinner) beforeCooking() { fmt.Println(fmt.Sprintf(\"%sMM 在洗菜切菜\", d.Name)) } func (d *TaiwanDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", d.Name, d.Name) } func (d *TaiwanDinner) afterCooking() { fmt.Println(fmt.Sprintf(\"%sMM 让你去品尝\", d.Name)) } 2.3.4 定义模板方法 func DoDinner(d Dinner2) { if !d.foodEnough() { d.doShopping() } d.beforeCooking() fmt.Println(d.doCooking()) d.afterCooking() d.eat() } func (ad AbstractDinner) eat() { fmt.Println(fmt.Sprintf(\"%sMM说：开吃喽\", ad.Name)) } 如果想把抽象方法放到结构体上，也可以如下： type Dinner2 interface { ... DoDinner(d Dinner2) } func (ad AbstractDinner) DoDinner(d Dinner2) { if !d.foodEnough() { d.doShopping() } d.beforeCooking() fmt.Println(d.doCooking()) d.afterCooking() ad.eat() } func (ad AbstractDinner) eat() { fmt.Println(fmt.Sprintf(\"%sMM说：开吃喽\", ad.Name)) } 到时候调用的话就 DoDinner 改成 d1 := NewTaiwanDinner(\"台湾\") d1.DoDinner(d1)。 2.3.5 运行例子 代码： func TestTemplate2(t *testing.T) { fmt.Println(\"---准备台湾餐---\") d1 := NewTaiwanDinner(\"台湾\") DoDinner(d1) fmt.Println(\"---准备杭州餐---\") d2 := NewHangzhouDinner(\"杭州\") DoDinner(d2) fmt.Println(\"---准备北京餐---\") d3 := NewTaiwanDinner(\"北京\") DoDinner(d3) } 输出结果： ---准备台湾餐--- 生鲜超市购买，一定要买茶叶蛋 台湾MM 在洗菜切菜 台湾MM 在做台湾菜 台湾MM 让你去品尝 台湾MM说：开吃喽 ---准备杭州餐--- 门口小贩买菜 杭州MM 在洗菜切菜 杭州MM 在做杭州菜 杭州MM 让你去品尝 杭州MM说：开吃喽 ---准备北京餐--- 生鲜超市购买，一定要买茶叶蛋 北京MM 在洗菜切菜 北京MM 在做北京菜 北京MM 让你去品尝 北京MM说：开吃喽 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:2:3","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"2.4、例子说明 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:2:4","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"三、开源框架使用场景 列举某几个框架，供大家参考 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:3:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"3.1 JDK AbstractList public abstract class AbstractList\u003cE\u003e extends AbstractCollection\u003cE\u003e implements List\u003cE\u003e { ... public void add(int index, E element) { throw new UnsupportedOperationException(); } ... public boolean addAll(int index, Collection\u003c? extends E\u003e c) { rangeCheckForAdd(index); boolean modified = false; for (E e : c) { add(index++, e); modified = true; } return modified; } ... } 实现类实现 add 的逻辑，如： public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable { // ... public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } // ... } ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:3:1","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"3.1 spring 中的 事务管理器 public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable { // ... public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException { Object transaction = doGetTransaction(); // Cache debug flag to avoid repeated checks. boolean debugEnabled = logger.isDebugEnabled(); if (definition == null) { // Use defaults if no transaction definition given. definition = new DefaultTransactionDefinition(); } if (isExistingTransaction(transaction)) { // Existing transaction found -\u003e check propagation behavior to find out how to behave. return handleExistingTransaction(definition, transaction, debugEnabled); } // Check definition settings for new transaction. if (definition.getTimeout() \u003c TransactionDefinition.TIMEOUT_DEFAULT) { throw new InvalidTimeoutException(\"Invalid transaction timeout\", definition.getTimeout()); } // No existing transaction found -\u003e check propagation behavior to find out how to proceed. if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) { throw new IllegalTransactionStateException( \"No existing transaction found for transaction marked with propagation 'mandatory'\"); } else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED || definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW || definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) { SuspendedResourcesHolder suspendedResources = suspend(null); if (debugEnabled) { logger.debug(\"Creating new transaction with name [\" + definition.getName() + \"]: \" + definition); } try { boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); doBegin(transaction, definition); prepareSynchronization(status, definition); return status; } catch (RuntimeException ex) { resume(null, suspendedResources); throw ex; } catch (Error err) { resume(null, suspendedResources); throw err; } } else { // Create \"empty\" transaction: no actual transaction, but potentially synchronization. if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT \u0026\u0026 logger.isWarnEnabled()) { logger.warn(\"Custom isolation level specified but no actual transaction initiated; \" + \"isolation level will effectively be ignored: \" + definition); } boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS); return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null); } } // ... protected abstract void doBegin(Object transaction, TransactionDefinition definition) throws TransactionException; ... } 这里只拿 getTransaction 和 doBegin 举例，非常标准的写法 getTransaction 还用了 final 描述，表示子类不允许改变。 当我自定义事务管理器的时候，比如每次事务开启创建一个 traceId，效果如下： public class GongDaoDataSourceTransactionManager extends DataSourceTransactionManager implements ResourceTransactionManager, InitializingBean, EnvironmentAware { // ... protected void doBegin(Object transaction, TransactionDefinition definition) { String currentXid; if (XIDContext.getCurrent() != null \u0026\u0026 null != XIDContext.getCurrent().getId()) { currentXid = xidGenerator.getXID(); XIDContext.childCurrent(new TransactionContent(currentXid, definition.getName())); } else { currentXid = xidGenerator.getXID(); XIDContext.setXid(new TransactionContent(currentXid, definition.getName())); } if (null == HyjalTransactionFileAppender.contextHolder.get()) { String logFileName = HyjalTransactionFileAppender.makeLogFileName(new Date(), HyjalTransactionFileAppender.logId.get()); HyjalTransactionFileAppender.contextHolder.set(logFileName); } try { if (null == XIDContext.getCurrentXid()) { XIDContext.setXid(xidGenerator.getXID()); } super.doBegin(transaction, definition); } finally { if (logger.isDebugEnabled()) { logger.debug(\"do begin Xi","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:3:2","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"四、优势和劣势 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:4:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"4.1 优势 对扩展开放，对修改关闭，符合“开闭原则” 定义标准算法，子类可自定义扩展，把变性和不变性分离 子类的扩展不会导致标准算法结构 能够提高代码复用，公共部分易维护 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:4:1","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"4.2 劣势 每一个实现类都需要定义自己的行为，如果复杂业务实现类会膨胀的比较多 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:4:2","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"五、参考 https://www.tutorialspoint.com/design_pattern/template_pattern.htm https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:5:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"}]