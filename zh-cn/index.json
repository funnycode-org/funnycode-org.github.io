[{"categories":["mybatis","java"],"content":"一、前言 今天调试分页查询代码的时候遇到一个奇葩的问题，该问题后来排查下来跟lombok的使用有关。我们在使用mybatis或者mybatis-plus的时候一般会定义一个类对应表的每个字段，一个成熟的java程序员喜欢使用lombok把代码简洁点。这是大前提，我直接说结论吧： 实体类最好都加上@Data,@AllArgsConstructor,@NoArgsConstructor才能避免我现在遇到的问题 ","date":"2021-01-04","objectID":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/:1:0","tags":["mybatis","lombok"],"title":"Mybatis反序列化sql查询结果异常","uri":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/"},{"categories":["mybatis","java"],"content":"二、我的问题 我的表: create table unimall.industry_output_value ( id bigint auto_increment primary key, month_output_value decimal(20,10) null, total_output_value decimal(20,10) null, total_increase_percent decimal(20,10) null, gmt_create datetime null, gmt_update datetime null, month datetime null ); 我的实体类: @Data @TableName(\"industry_output_value\") @Builder public class OutputValueDO extends SuperDO { private BigDecimal monthOutputValue; private BigDecimal totalOutputValue; private BigDecimal totalIncreasePercent; @TableField(\"`month`\") private Date month; } @Data public class SuperDO { private Long id; @TableField(\"gmt_update\") private Date gmtUpdate; @TableField(\"gmt_create\") private Date gmtCreate; } 然后一个普通的select查询的时候报了下面这个错误: Caused by: org.springframework.dao.DataIntegrityViolationException: Error attempting to get column 'total_increase_percent' from result set. Cause: java.sql.SQLDataException: Unsupported conversion from DECIMAL to java.sql.Timestamp ; Unsupported conversion from DECIMAL to java.sql.Timestamp; nested exception is java.sql.SQLDataException: Unsupported conversion from DECIMAL to java.sql.Timestamp at org.springframework.jdbc.support.SQLExceptionSubclassTranslator.doTranslate(SQLExceptionSubclassTranslator.java:84) ~[spring-jdbc-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:72) ~[spring-jdbc-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81) ~[spring-jdbc-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:88) ~[mybatis-spring-2.0.3.jar:2.0.3] at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:440) ~[mybatis-spring-2.0.3.jar:2.0.3] at com.sun.proxy.$Proxy84.selectList(Unknown Source) ~[na:na] ... Caused by: java.sql.SQLDataException: Unsupported conversion from DECIMAL to java.sql.Timestamp ... at org.apache.ibatis.type.DateTypeHandler.getNullableResult(DateTypeHandler.java:39) ~[mybatis-3.5.3.jar:3.5.3] at org.apache.ibatis.type.DateTypeHandler.getNullableResult(DateTypeHandler.java:28) ~[mybatis-3.5.3.jar:3.5.3] at org.apache.ibatis.type.BaseTypeHandler.getResult(BaseTypeHandler.java:81) ~[mybatis-3.5.3.jar:3.5.3] ... Caused by: com.mysql.cj.exceptions.DataConversionException: Unsupported conversion from DECIMAL to java.sql.Timestamp at com.mysql.cj.result.DefaultValueFactory.unsupported(DefaultValueFactory.java:47) ~[mysql-connector-java-8.0.15.jar:8.0.15] ... 可以看到异常很奇怪，我的total_increase_percent明明是BigDecimal，为何要被反序列化为java.util.Date呢？ 后面修改为如下代码就正常了: @Data @TableName(\"industry_output_value\") @Builder @AllArgsConstructor @NoArgsConstructor public class OutputValueDO extends SuperDO { private BigDecimal monthOutputValue; private BigDecimal totalOutputValue; private BigDecimal totalIncreasePercent; @TableField(\"`month`\") private Date month; } ","date":"2021-01-04","objectID":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/:2:0","tags":["mybatis","lombok"],"title":"Mybatis反序列化sql查询结果异常","uri":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/"},{"categories":["mybatis","java"],"content":"二、问题排查 ","date":"2021-01-04","objectID":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/:3:0","tags":["mybatis","lombok"],"title":"Mybatis反序列化sql查询结果异常","uri":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/"},{"categories":["mybatis","java"],"content":"首先定位到问题出现在哪里 由于 columnName是total_increase_percent，该列不是timestamp，类型不一致，所以报异常。所以要看卡rs是如何获取到的以及为何使用了org.apache.ibatis.type.DateTypeHandler转换该字段。 ","date":"2021-01-04","objectID":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/:3:1","tags":["mybatis","lombok"],"title":"Mybatis反序列化sql查询结果异常","uri":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/"},{"categories":["mybatis","java"],"content":"org.apache.ibatis.type.DateTypeHandler的获取 点击调用栈的红框出，跳转到rs和org.apache.ibatis.type.DateTypeHandler的获取处。 在createUsingConstructor方法这里既取到了typeHandler，又获取到了rs。 我们可以推断出，应该是通过columnName和parameterType获取typeHandler出错了。 我们看看这里的代码: for(int i = 0; i \u003c constructor.getParameterTypes().length; ++i) { Class\u003c?\u003e parameterType = constructor.getParameterTypes()[i]; String columnName = (String)rsw.getColumnNames().get(i); TypeHandler\u003c?\u003e typeHandler = rsw.getTypeHandler(parameterType, columnName); Object value = typeHandler.getResult(rsw.getResultSet(), columnName); ... } 看看parameterType,columnName,typeHandler三个值的类型： ok,这几个值都吻合了，根据代码1-3行我们看出parameterType和columnName没对上导致的。这里可以推断出constructor出现了问题，为啥不怀疑是columnName出现了问题了呢？因为rsw是获取到sql返回结果构造的，是mybatis的代码，大概率不会出现问题。 ","date":"2021-01-04","objectID":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/:3:2","tags":["mybatis","lombok"],"title":"Mybatis反序列化sql查询结果异常","uri":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/"},{"categories":["mybatis","java"],"content":"constructor分析 这是constructor的parameterTypes: 这里出现了4个字段，但是没有id, gmtUpdate,gmtCreate这几个字段，而看看rsw的columnNames的值： 这里却多了id, gmtUpdate,gmtCreate这几列，问题有进一步定位到了，原来是构造器的字段和rsw的columnNames不一一对应导致的。可以从上面代码for循环得知，都是根据索引一一获取，这里个数都对不上，肯定有问题了。 在这里基本上已经定位到问题了，就是构造器只接受了3个参数导致的。 ","date":"2021-01-04","objectID":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/:3:3","tags":["mybatis","lombok"],"title":"Mybatis反序列化sql查询结果异常","uri":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/"},{"categories":["mybatis","java"],"content":"如何获取到的constructor 把方法栈在往上移一个，就能找到constructor的具体获取处： resultType就是我的实体类，defaultConstructor通过findDefaultConstructor获取到，这个方法就不细看了，里面逻辑就是：如果只有一个构造器，那就使用该构造器，获取寻找被标记了AutomapConstructor注解的构造器。由于@Data注解只能生成一个构造器OutputValueDO(java.math.BigDecimal,java.math.BigDecimal,java.math.BigDecimal,java.util.Date)，没有id, gmtUpdate,gmtCreate。 此时就有一个解决方案了，去掉@Data，自己写一个完整的构造器，包括继承的所有字段，但是这样是不太好的，从上面for循环代码可知，要数据库的表的列的顺序要和实体类的构造器的参数的顺序一致，不然还是出现问题。那就在往上个方法栈看看为什么使用了该处理逻辑，印象中的mybatis没这么坑。 ","date":"2021-01-04","objectID":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/:3:4","tags":["mybatis","lombok"],"title":"Mybatis反序列化sql查询结果异常","uri":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/"},{"categories":["mybatis","java"],"content":"更优雅的解决方案 再往上到上一个方法栈， createResultObject方法就找到了正主。 由于!resultType.isInterface() \u0026\u0026 !metaType.hasDefaultConstructor()判断为真就走到了通过构造器反射得到结果的逻辑。接下来分别分析这个 if...else... hasTypeHandlerForResultObject明显我们没有定义自己的typeHandler，故忽略 constructorMappings表示在mapper.xml中定义了实体类的字段和表字段的映射关系，但是我们没有定义，忽略 我的实体类OutputValueDO不是接口，并且没有无参构造器，我的代码正好适合这个判断，所以我要想办法是这个判断为假。 最后一个就是默认的，我要改成走到这个方法来。 解决方案方向：加个默认构造器。加@NoArgsConstructor即可解决，该注解就能生成无参构造器，由于我加了@Builder，所以我还必须加@AllArgsConstructor，稳了，解决了。 ","date":"2021-01-04","objectID":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/:3:5","tags":["mybatis","lombok"],"title":"Mybatis反序列化sql查询结果异常","uri":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/"},{"categories":["mybatis","java"],"content":"三、总结 我一般使用lombok最好加上这几个注解： @Data @Builder @AllArgsConstructor @NoArgsConstructor 但是这个代码一开始不是我写的，而且该实体类没有继承的话也不会出问题，巧了。以前也看过mybatis的代码，但是没有翻过映射这块。今天再一次体味到了mybatis的代码：真正牛的代码不需要注释。很容易就找到了问题。 ","date":"2021-01-04","objectID":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/:4:0","tags":["mybatis","lombok"],"title":"Mybatis反序列化sql查询结果异常","uri":"/zh-cn/2021/01/04/mybatis-resulttype-map-error/"},{"categories":["json"],"content":"一、前言 其实本篇应该写的是json的反序列化，所以花了几个晚上看了下该部分源码，每次看都想睡觉。为什么呢？因为确实是太无聊了，我打赌这是我看过go源码中最无聊的逻辑，全篇都是一些状态的切换，要么是 if ... else ... ，要么就是 switch ... case ... case ...,头大。我也尝试画过流程图，但是这么多状态的切换，也不知道是什么力量支撑我画了2天时间，最后我放弃了-画出来没有丝毫意义。所以本篇我就源码层面顺着json：你或许还不知道的使用的坑（一）续写下反序列化可能会遇到的一些坑或者未知的使用方法。 ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:0:0","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json"],"content":"tips: 我在看的过程中也留了些注释，看兴趣的话可以去GitHub上去看看，也欢迎你的加入。 所有代码在 The Go Playground都能看到。 二、内容 ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:1:0","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json"],"content":"1.反序列化科学计数法 假如你有这么个json字符串，如何序列化呢？ { \"Name\": \"zhangSan\", \"Age\": -0e+10000 } 注意Age字段的值并没有被双引号包围，所以go提供了一种类型json.Number专门用来装数字，包括科学计数法和普通数字。下面是我的结构体： type User struct { Name string Age json.Number } 运行我的示例代码能得到正确结果： {zhangSan -0e+10000} ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:2:0","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json"],"content":"2.value是null的注意 假如我有这么个json字符串： { \"Name\": null, \"Age\": null } 且我的结构体是这样的： type User struct { Name string Age map[string]string } 我的序列化代码如下: var san = User{ Name: \"aaa\", Age: map[string]string{\"1\": \"1\"}, } err := json.Unmarshal(bytes, \u0026san) if err != nil { fmt.Println(\"error:\", err) } else { fmt.Println(san) } 你觉得打印结果会是神马样子的呢？ {aaa map[]} 会有点不可思议是吧？为什么Name的值没有改变，但是Age确被重新初始化了呢？ go的官方序列化代码如下: case 'n': // null // The main parser checks that only true and false can reach here, // but if this was a quoted string input, it could be anything. if fromQuoted \u0026\u0026 string(item) != \"null\" { // 字段有',string'标签，以n开头，必须是null d.saveError(fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal %q into %v\", item, v.Type())) break } switch v.Kind() { case reflect.Interface, reflect.Ptr, reflect.Map, reflect.Slice: // 设置给interface{},指针,map,切片一个初始化的值 v.Set(reflect.Zero(v.Type())) // otherwise, ignore null for primitives/string } ok,能看到10~12行把该字段重新设置为0值了,不仅map,还有interface,指针,slice都会发生这种情况，除了这种情况，其他的值都不会被改变。 ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:3:0","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json"],"content":"3.反序列到接口，必须是空接口 常理任何json字段都可以序列化到接口的，但是需要注意下，go只允许空接口 interface{}，如果你的接口有方法的话是不被允许的。例如你有如下结构体： type User struct { Name string Age interface { GetAge() int } } 可以看到 Age字段是一个非空接口，当我反序列化该json字符串的时候： { \"Name\": null, \"Age\": 19 } 会发生异常,示例代码： error: json: cannot unmarshal number into Go struct field User.Age of type interface { GetAge() int } go的代码在这里: case reflect.Interface: if v.NumMethod() == 0 { // 空接口 v.Set(reflect.ValueOf(value)) } else { // 非空接口 d.saveError(\u0026UnmarshalTypeError{Value: \"bool\", Type: v.Type(), Offset: int64(d.readIndex())}) // 接口 } v.NumMethod() == 0表示必须是个空接口。 ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:4:0","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json"],"content":"4.不要把数组当做反序列化的字段类型 ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:5:0","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json"],"content":"4.1 虽然说一般来说我们都是用切片，但是也还是拎出来讲一讲下，可能会导致少反序列化些数组值。 假如我有这么个结构体： type User struct { Name string Age [1]int } 而我的json字符串长这样: { \"Name\": \"zhangSan\", \"Age\": [20,21] } 反序列化代码的结果如下: {zhangSan [20]} 可以看到只序列化了数组的长度个数，其他都被抛弃了，而且没有任何错误提示。 go的源码在这里: if i \u003c v.Len() { // Decode into element. if err := d.value(v.Index(i)); err != nil { return err } } else { // Ran out of fixed array: skip. if err := d.value(reflect.Value{}); err != nil { return err } } i表示json字符串里面的数组的长度，因为 i大于 v.Len()（数组的长度)的时候，就表示结构体的数组太短了，在第8行简单的忽略了。 ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:5:1","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json"],"content":"4.2 当数组被初始化过非0值，反序列化会被置为0 结构体如下： type User struct { Name string Age [2]int } 反序列化代码如下： var data = []byte (` { \"Name\": \"zhangSan\", \"Age\": [20] } `) var san = User{ Age: [2]int{1, 2}, } err := json.Unmarshal(data, \u0026san) if err != nil { fmt.Println(\"error:\", err) } else { fmt.Println(san) } 在第8行被初始化之后，反序列化之后结果就是为0值了，结果如下: {zhangSan [20 0]} go得源码在这里: if i \u003c v.Len() { if v.Kind() == reflect.Array { // Array. Zero the rest. z := reflect.Zero(v.Type().Elem()) for ; i \u003c v.Len(); i++ { v.Index(i).Set(z) } } else { v.SetLen(i) } } i表示的是json字符串的数组的长度，当 i小于v.Len()(数组的长度)的时候，会把元素设置为reflect.Zero(v.Type().Elem())。 ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:5:2","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json"],"content":"5.map的key不是int或者string，怎么操作？ 一招解决：实现接口encoding.TextUnmarshaler。这个我就不举列子了。 go的源码在这： switch v.Kind() { case reflect.Map: // Map key must either have string kind, have an integer kind, // or be an encoding.TextUnmarshaler. switch t.Key().Kind() { case reflect.String, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr: default: if !reflect.PtrTo(t.Key()).Implements(textUnmarshalerType) { d.saveError(\u0026UnmarshalTypeError{Value: \"object\", Type: t, Offset: int64(d.off)}) d.skip() return nil } } if v.IsNil() { v.Set(reflect.MakeMap(t)) } 当时map类型的时候，key不是string或者integer,那么如果实现了textUnmarshalerType也是可以的。 三、另外一种装逼的反序列方式 你可知除了json.Unmarshal()这种方式，还有另外一种反序列的编码方式: var data = []byte (` { \"Name\": \"zhangSan\", \"Age\": 19 } `) var san = User{ } decoder := json.NewDecoder(bytes.NewReader(data)) decoder.Decode(\u0026san) if err != nil { fmt.Println(\"error:\", err) } else { fmt.Println(san) } 当然装逼不是目的，目的是我们能做更多的反序列化的行为控制. ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:6:0","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json"],"content":"1.把数字当做json.Number类型反序列化到接口里面去 这样有什么意义呢？因为go的做法是默认把数字反序列化成float64类型，但是当该数字很大的时候，float64是表示不了的，所以此时就要用json.Number，但是用json.Unmarshal()是做不到的，此时用json.NewDecoder()就可以的。 下面是错误的示例代码： type User struct { Name string Age interface{} } func main() { var data = []byte (` { \"Name\": \"zhangSan\", \"Age\": 2e+1000 } `) var san = User{ } decoder := json.NewDecoder(bytes.NewReader(data)) //decoder.UseNumber() err := decoder.Decode(\u0026san) if err != nil { fmt.Println(\"error:\", err) } else { fmt.Println(san) } } 错误结果如下： error: json: cannot unmarshal number 2e+1000 into Go struct field User.Age of type float64 只需要把第16行的代码取消注释即可达到目的。 让我们看看go的源码说明: // UseNumber causes the Decoder to unmarshal a number into an interface{} as a // Number instead of as a float64. func (dec *Decoder) UseNumber() { dec.d.useNumber = true } 注释已经讲的很明白了。 再看看具体怎么使用useNumber这个参数的： // convertNumber converts the number literal s to a float64 or a Number // depending on the setting of d.useNumber. func (d *decodeState) convertNumber(s string) (interface{}, error) { if d.useNumber { return Number(s), nil } f, err := strconv.ParseFloat(s, 64) if err != nil { return nil, \u0026UnmarshalTypeError{Value: \"number \" + s, Type: reflect.TypeOf(0.0), Offset: int64(d.off)} } return f, nil } 第4~5行也说明了使用json.Number类型获得结果。 ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:7:0","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["json"],"content":"2.当json字符串某个字段没有在结构体中对应的时候 默认情况下json是允许这种情况下的，那如何禁止这种情况呢？ 这是我的结构体： type User struct { Name string Age interface{} } 我的json字符串： { \"Name\": \"zhangSan\", \"Age\": 2e+1000, \"Head\": \"http://head.jpg\" } 我的反序列化代码: var san = User{ } decoder := json.NewDecoder(bytes.NewReader(data)) decoder.UseNumber() decoder.DisallowUnknownFields() err := decoder.Decode(\u0026san) if err != nil { fmt.Println(\"error:\", err) } else { fmt.Println(san) } 结果会报错，提示找不到Head字段： error: json: unknown field \"Head\" json的源码在这里： if d.disallowUnknownFields { // 判断是否允许没有字段可序列化的情况 d.saveError(fmt.Errorf(\"json: unknown field %q\", key)) } 四、写到最后 上面总结了反序列化的注意一点，由于我的水平有限，并且我也是根据源码倒推过来的，可能还有更深层次的技巧或坑我还没有发现。如果你在工作过程中遇到序列化或者反序列化的问题，欢迎和我交流。可以加我微信，或者微信公众号，我会长期输出原创文章。 我的微信： 我的微信公众号: ","date":"2020-12-26","objectID":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/:8:0","tags":["json"],"title":"json：你或许还不知道的使用的坑（三）续","uri":"/zh-cn/2020/12/26/go-sourcecode-json-unmarshal/"},{"categories":["go源码"],"content":"本文是 map 源码系列第一篇，带你走进 map 为什么分析map 在计算机编程语言当中，用的最多的数据结构估计就是map。map以他近乎o(1)的查找效率和修改效率让他在大多数场景下都比较受青睐。map的常规的实现方式都是hash+其他数据结构，如java是hash+红黑树，而我现在即将要分析的go的实现方式是hash+链表。我会分析map的几乎每段代码，并且在我的GitHub可以查看到我的分析，注释十分详尽，欢迎批评指正。我的打算是把一些常用的数据结构都分析一遍，如果有志同道合的人，可以联系我。 ","date":"2020-11-25","objectID":"/zh-cn/2020/11/25/go-sourcecode-map-first/:0:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"我的环境 为了给那些感兴趣看源码分析我的博客的同学阅读得更加清晰，列举了我的环境： go1.14.7 amd64； windows和mac接口，linux没有测试，估计没问题 ； goland,目前最好的golang ide，虽然笔者用起来感觉还是不太完美； 着重分析map[string]string，其他类型的源码变化不大 ； ","date":"2020-11-25","objectID":"/zh-cn/2020/11/25/go-sourcecode-map-first/:1:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"本篇重点 1.go的map和java的map有区别，go中是一个关键字，而java确实可以直接查看源码，那么如何分析go的map源码？ 2.调试过程当中，go充斥着大量指针，如何知道指针指向的内容？map的最小单位bmap除了查看tophash，怎么查看里面的其他隐藏字段？ 3.go的map源码为何给不同的key的类型设计不同的实现？ 4.其他一些查看源码的小技巧：内存对齐、指针偏移、类型大小等等 ","date":"2020-11-25","objectID":"/zh-cn/2020/11/25/go-sourcecode-map-first/:2:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"如何找到map对应的源码 go的map的结构体是hmap，代码位于runtime/map.go,当编译器编译你申明使用map的源码时候，其实是使用了runtime/map*.go,后面对map的增删改查都是执行该代码，故要弄懂map的底层原理只需要分析该源码，也可以断点调试。 我下面有个自己测试的源码，注意我编译之后查看，就可以发现端倪： package main import \"fmt\" func main() { m1 := make(map[string]string) fmt.Println(m1) m2 := make(map[string]string, 8) fmt.Println(m2) m3 := make(map[string]string, 9) fmt.Println(m3) m4 := map[string]string{} fmt.Println(m4) m3[\"1\"] = \"2\" for k, v := range m3 { fmt.Println(k) fmt.Println(v) } v1 := m3[\"1\"] fmt.Println(v1) if v2, ok := m3[\"1\"]; ok { fmt.Println(v2) } } 上面代码有几种不同申明map的方式，对应runtime/map.go也不同。还有赋值和遍历查找的代码。 下面编译得到汇编指令文件，执行 go tool compile -N -l -S main.go \u003e main.txt 生成了汇编指令文件: \"\".main STEXT size=1891 args=0x0 locals=0x288 0x0000 00000 (main.go:5) TEXT \"\".main(SB), ABIInternal, $648-0 0x0000 00000 (main.go:5) MOVQ TLS, CX 0x0009 00009 (main.go:5) PCDATA $0, $-2 0x0009 00009 (main.go:5) MOVQ (CX)(TLS*2), CX 0x0010 00016 (main.go:5) PCDATA $0, $-1 0x0010 00016 (main.go:5) LEAQ -520(SP), AX 0x0018 00024 (main.go:5) CMPQ AX, 16(CX) 0x001c 00028 (main.go:5) PCDATA $0, $-2 0x001c 00028 (main.go:5) JLS 1881 0x0022 00034 (main.go:5) PCDATA $0, $-1 0x0022 00034 (main.go:5) SUBQ $648, SP 0x0029 00041 (main.go:5) MOVQ BP, 640(SP) 0x0031 00049 (main.go:5) LEAQ 640(SP), BP 0x0039 00057 (main.go:5) PCDATA $0, $-2 0x0039 00057 (main.go:5) PCDATA $1, $-2 0x0039 00057 (main.go:5) FUNCDATA $0, gclocals·ad6397d3d33bbb6a31b1320349e23274(SB) 0x0039 00057 (main.go:5) FUNCDATA $1, gclocals·1bbf1965a34fa71a63e073b1cf2d752a(SB) 0x0039 00057 (main.go:5) FUNCDATA $2, gclocals·658035074399f748be6dd39603d5113c(SB) 0x0039 00057 (main.go:5) FUNCDATA $3, \"\".main.stkobj(SB) 0x0039 00057 (main.go:6) PCDATA $0, $0 0x0039 00057 (main.go:6) PCDATA $1, $0 0x0039 00057 (main.go:6) CALL runtime.makemap_small(SB) 0x003e 00062 (main.go:6) PCDATA $0, $1 0x003e 00062 (main.go:6) MOVQ (SP), AX 0x0042 00066 (main.go:6) MOVQ AX, \"\".m1+80(SP) 0x0047 00071 (main.go:7) PCDATA $0, $0 0x0047 00071 (main.go:7) PCDATA $1, $1 0x0047 00071 (main.go:7) MOVQ AX, \"\"..autotmp_10+200(SP) 0x004f 00079 (main.go:7) PCDATA $1, $2 0x004f 00079 (main.go:7) XORPS X0, X0 0x0052 00082 (main.go:7) MOVUPS X0, \"\"..autotmp_9+272(SP) 0x005a 00090 (main.go:7) PCDATA $0, $1 0x005a 00090 (main.go:7) PCDATA $1, $1 0x005a 00090 (main.go:7) LEAQ \"\"..autotmp_9+272(SP), AX 0x0062 00098 (main.go:7) MOVQ AX, \"\"..autotmp_15+192(SP) 0x006a 00106 (main.go:7) TESTB AL, (AX) 0x006c 00108 (main.go:7) PCDATA $0, $2 0x006c 00108 (main.go:7) PCDATA $1, $0 0x006c 00108 (main.go:7) MOVQ \"\"..autotmp_10+200(SP), CX 0x0074 00116 (main.go:7) PCDATA $0, $3 0x0074 00116 (main.go:7) LEAQ type.map[string]string(SB), DX 0x007b 00123 (main.go:7) PCDATA $0, $2 0x007b 00123 (main.go:7) MOVQ DX, \"\"..autotmp_9+272(SP) 0x0083 00131 (main.go:7) PCDATA $0, $1 0x0083 00131 (main.go:7) MOVQ CX, \"\"..autotmp_9+280(SP) 0x008b 00139 (main.go:7) TESTB AL, (AX) 0x008d 00141 (main.go:7) JMP 143 0x008f 00143 (main.go:7) MOVQ AX, \"\"..autotmp_14+520(SP) 0x0097 00151 (main.go:7) MOVQ $1, \"\"..autotmp_14+528(SP) 0x00a3 00163 (main.go:7) MOVQ $1, \"\"..autotmp_14+536(SP) 0x00af 00175 (main.go:7) PCDATA $0, $0 0x00af 00175 (main.go:7) MOVQ AX, (SP) 0x00b3 00179 (main.go:7) MOVQ $1, 8(SP) 0x00bc 00188 (main.go:7) MOVQ $1, 16(SP) 0x00c5 00197 (main.go:7) CALL fmt.Println(SB) 0x00ca 00202 (main.go:8) CALL runtime.makemap_small(SB) 0x00cf 00207 (main.go:8) PCDATA $0, $1 0x00cf 00207 (main.go:8) MOVQ (SP), AX 0x00d3 00211 (main.go:8) MOVQ AX, \"\".m2+72(SP) 0x00d8 00216 (main.go:9) PCDATA $0, $0 0x00d8 00216 (main.go:9) PCDATA $1, $1 0x00d8 00216 (main.go:9) MOVQ AX, \"\"..autotmp_10+200(SP) 0x00e0 00224 (main.go:9) PCDATA $1, $2 0x00e0 00224 (main.go:9) XORPS X0, X0 0x00e3 00227 (main.go:9) MOVUPS X0, \"\"..autotmp_9+272(SP) 0x00eb 00235 (main.go:9) PCDATA $0, $1 0x00eb 00235 (main.go:9) PCDATA $1, $1 0x00eb 00235 (main.go:9) LEAQ \"\"..autotmp_9+272(SP), AX 0x00f3 00243 (main.go:9) MOVQ AX, \"\"..autotmp_17+184(SP) 0x00fb 00251 (main.go:9) TESTB AL, (AX) 0x00fd 00253 (main.go:9) PCDATA $0,","date":"2020-11-25","objectID":"/zh-cn/2020/11/25/go-sourcecode-map-first/:3:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"go的map对应的结构体hmap go的map的基础结构体是hmap,在runtime/map.go中， // A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler's definition. // map存储的键值对个数 count int // # live cells == size of map. Must be first (used by len() builtin) // 表示map的一些标志位 flags uint8 // map的桶的2的对数就是B值 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) // 溢出桶个数，是个近似数，不完全相等 noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details // hash种子 hash0 uint32 // hash seed // 桶，真正存数据的地方，2^B个桶 buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. // 保存一些即将迁移的桶 oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing // 从oldbuckets迁移到新的buckets的进度 nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) // 当key不是指针类型的数据的时候，里面会存溢出桶，这样会避免go的扫描 extra *mapextra // optional fields } 既然是map结构体，为何注释说是一个header呢？这是因为buckets和oldbuckets这2个字段并没有真正存取数据，只是存了一个指针，指向存取buckets的地址，故我们在使用过程中拷贝hmap的时候，并没有真正拷贝map的数据，只是拷贝了hmap这个结构体的一些数据。 在看看hmap的字段mapextra: // mapextra holds fields that are not present on all maps. type mapextra struct { // If both key and elem do not contain pointers and are inline, then we mark bucket // 如果key和value都不包括指针并且内敛，然后我们就标记bucket没有指针 // type as containing no pointers. This avoids scanning such maps. // 这样会避免gc扫描 // However, bmap.overflow is a pointer. In order to keep overflow buckets // 但是，虽然key和value不包括指针，但是逸出桶却是个指针，为了让逸出桶一直 // alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow. // 存在，所以就把逸出桶和需要迁移的逸出桶的指针存到hamp的extra字段里面 // overflow and oldoverflow are only used if key and elem do not contain pointers. // 如果key和elme包含指针，overflow和oldoverflow就不会被使用了 // overflow contains overflow buckets for hmap.buckets. // oldoverflow contains overflow buckets for hmap.oldbuckets. // The indirection allows to store a pointer to the slice in hiter. overflow *[]*bmap oldoverflow *[]*bmap // nextOverflow holds a pointer to a free overflow bucket. nextOverflow *bmap } 如mapextra结构体为啥说有些字段并不会在所有map里面全部都有呢？mapextra是一个为了优化bucket而设计的，当key或value是指针的时候，此时overflow和oldoverflow就不会被使用，只有nextOverflow会被使用，该字段保存了预先申请的逸出桶，在没有发生扩容的时候，而一个桶或者说bmap的8个tophash都被使用完了，那么就要考虑使用逸出桶。 当key和value都没有指针的时候bucket的bmap的_type的ptrdata就是0，意味着该结构体是没有指针的，申请bmap内存的时候，会申请一个没有指针的span，这样会避免gc扫描该内存，会提高效率，但是bmap的最后一个内存块是确确实实存放指针的，所以用uintptr存储着该map的逸出桶的地址，但是由于没有指向下一个逸出桶，可能会被gc回收掉，所以就需要overflow存取指向该逸出桶的指针避免被gc回收掉。 overflow和oldoverflow的用处差不多，只是oldoverflow为了迁移使用，后面的系列会详说。 ","date":"2020-11-25","objectID":"/zh-cn/2020/11/25/go-sourcecode-map-first/:4:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"bucket的结构体bmap bmap就是真正存数据的结构体了,bmap在源码中定义十分简单： // A bucket for a Go map. type bmap struct { // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] \u003c minTopHash, // tophash[0] is a bucket evacuation state instead. tophash [bucketCnt]uint8 // Followed by bucketCnt keys and then bucketCnt elems. // NOTE: packing all the keys together and then all the elems together makes the // code a bit more complicated than alternating key/elem/key/elem/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer. } 但其实真正的在内存中分配的结构体是这样的： // A bucket for a Go map. type bmap struct { // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] \u003c minTopHash, // tophash[0] is a bucket evacuation state instead. tophash [bucketCnt]uint8 keys [bucketCnt]string // 由于我举例的key是string，故我这里写string values [bucketCnt]string // 由于上面我的例子的value的类型是string，故这里也是string pointer unsafe.pointer // 由于key和value都是指针，所以这里是一个指针 // Followed by bucketCnt keys and then bucketCnt elems. // NOTE: packing all the keys together and then all the elems together makes the // code a bit more complicated than alternating key/elem/key/elem/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer. } 隐藏的字段在map源码中都是靠地址偏移来得到，tophash我们能轻易找到位置，但是如何找到keys、values和pointer呢？ 在map中是这么做的： dataOffset = unsafe.Offsetof(struct { b bmap v int64 }{}.v) 在64位机器上，需要对齐8个字节，这里int64正好也是8个字节，所以恰好解决内存对齐的问题，找到v的起始地址也就是values的起始地址: dataOffset+bucketCnt*2*sys.PtrSize // string16个字节，相当于2个指针，bucketCnt等于8 pointer的起始地址 dataOffset+bucketCnt*2*sys.PtrSize+sys.PtrSize tophash存的是key的hash高8位，为了方便查找key，为什么keys和values分别存在一堆呢？不是k|v|k|v这种呢？由于key和value的变量类型可能不一样，对齐系数不一致，可能导致内存不紧凑而浪费内存，所以把8个keys存到一堆，8个values存到一堆，然后最后在pointer之前对齐就可以了。所以此时也能算出来整个bmap的大小: bucketCnt*(uint8的字节为1)+bucketCnt*(string的字节16)+bucketCnt*(string的字节16)+指针大小8字节 = 272 在真正调试的时候如查看bucket里面的具体的key和value呢？这里给大家展示一个小技巧，如果大家有其他方法，可以留言讨论： type dmap struct { tophash [bucketCnt]uint8 debugKeys [bucketCnt]string debugElems [bucketCnt]string //debugOverflows unsafe.Pointer debugOverflows uintptr } 这是我定义的调试结构体，将该代码和bmap的结构体放到一堆，当你获取到bmap桶的地址的时候，就可以如下转换，就可以查看bmap的具体值了： b0 := (*dmap)(add(buckets, uintptr(0)*uintptr(t.bucketsize))) println(b0.debugOverflows) buckets假设是桶数组的起始地址，加上bucketsize就会得到第二个桶的起始地址，然后直接转型为*dmap,最后你可以可以打印出来你想查看的真实的值了。 ","date":"2020-11-25","objectID":"/zh-cn/2020/11/25/go-sourcecode-map-first/:5:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"map的整体结构 如果申请内存桶的时候又多余的溢出桶，那么mapextra的nextOverflow就会指向[]bmap其中的某块桶的地址，地址后之后的桶都是溢出桶。在一个桶装不下的时候，会去溢出桶拿桶然后bmap的overflow指向溢出桶。 ","date":"2020-11-25","objectID":"/zh-cn/2020/11/25/go-sourcecode-map-first/:6:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/2020/11/25/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"总结 上面大概介绍了map的数据结构，后面系列map的具体代码分析，包括增、删、改、查、扩容等都会分篇细解，如有不足之处，请共同讨论学习。 ","date":"2020-11-25","objectID":"/zh-cn/2020/11/25/go-sourcecode-map-first/:7:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/2020/11/25/go-sourcecode-map-first/"},{"categories":["Hugo"],"content":"本文介绍如何使 Hugo 博客在 GitHub 自动部署","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"一、前言 使用 Hugo 有一些时间了，把内容上传到 GitHub Pages，从一开始的手动操作，到脚本操作，终于来到了自动化部署。 部署的流程： 本地通过 Hugo 命令创建文件，编写博客，编写好后把改变的内容上传到 GitHub 博客源文件仓库。通过 GitHub Action 自动触发脚本构建，然后把静态文件通过 GitHub Deploy 到博客仓库。 ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:1:0","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"二、具体步骤 ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:2:0","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.1 创建两个仓库 创建博客源仓库 创建博客静态资源仓库 ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:2:1","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.2 创建 SSH 需要生成一对 SSH Key，生成的 Public Key 和 Private Key 都会用到。 ssh-keygen -t rsa -b 4096 -C \"ironcity.hz@gmail.com\" Generating public/private rsa key pair. Enter file in which to save the key (/Users/tc/.ssh/id_rsa): 输入你需要指定的文件，比如 /Users/tc/.ssh/id_rsa_hugo_deploy 只是为了防止覆盖之前创建的默认文件 ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:2:2","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.2 配置博客静态资源仓库的 Deploy Keys 添加公钥到 funnycode-org.github.io 仓库的 Deploy Keys 添加后 ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:2:3","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.3 配置博客源内容仓库的 Secrets 添加私钥到 blog 仓库的 Secrets 添加后 注意这个 secrets 的名称 ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:2:4","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.4 编写博客 克隆 blog 项目到本地 # 选取一个目录 cd ~/Desktop/ # 克隆 source 仓库 git clone git@github.com:funnycode-org/blog.git # 进入仓库 cd blog 创建 hugo 博客 # 创建博客，多语言模式 hugo new /posts/[blog-name]/index.zh-cn.md # 运行预览效果 hugo serve -D 如果没有什么问题就可以准备提交代码了 git add . git commit -m \"update commit\" git push -u origin master ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:2:5","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.5 GitHub Actions 说明 Actions 内容： name: Deploy Hugo Site to Github Pages on Master Branch on: push: branches: - master jobs: build-deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: '0.76.0' # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: funnycode-org/funnycode-org.github.io # remote branch publish_dir: \"./docs\" cname: blog.funnycode.org.cn keep_files: false # remove existing files publish_branch: docs # deploying branch commit_message: ${{ github.event.head_commit.message }} 注意点： publish_dir 指定发布的目录，./docs 指 blog 项目下的 docs 目录下的内容会被发布 publish_branch 发布到 funnycode-org.github.io 项目的 docs 分支 secrets.ACTIONS_DEPLOY_KEY 的 ACTIONS_DEPLOY_KEY 则是上面设置 Private Key 的变量名 cname 必须要配置好，和下文提到的 Setting 里面配置图对应 ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:2:6","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"2.7 funnycode-org.github.io 配置 配置 Setting 验证访问 输入 https://blog.funnycode.org.cn，效果： ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:2:7","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":["Hugo"],"content":"三、参考 https://github.com/peaceiris/actions-hugo https://zhuanlan.zhihu.com/p/109057290 https://github.com/peaceiris/actions-gh-pages ","date":"2020-06-11","objectID":"/zh-cn/2020/06/11/hugo-github-action/:3:0","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/2020/06/11/hugo-github-action/"},{"categories":[],"content":"一、题目 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode225-implement-stack-using-queues/:1:0","tags":[],"title":"LeetCode225题笔记","uri":"/zh-cn/notes/leetcode225-implement-stack-using-queues/"},{"categories":[],"content":"1.1 题目说明 使用队列实现栈的下列操作： push(x) – 元素 x 入栈 pop() – 移除栈顶元素 top() – 获取栈顶元素 empty() – 返回栈是否为空 注意: 你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。 leetcode地址 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode225-implement-stack-using-queues/:1:1","tags":[],"title":"LeetCode225题笔记","uri":"/zh-cn/notes/leetcode225-implement-stack-using-queues/"},{"categories":[],"content":"1.2 审题 栈 参考之前的笔记。 什么是队列？ 队列是一个 FIFO 先进先出的数据结构。 基本操作和栈类似，称为 出队和入队。 go 的队列？ 直接就用数组去表示。 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode225-implement-stack-using-queues/:1:2","tags":[],"title":"LeetCode225题笔记","uri":"/zh-cn/notes/leetcode225-implement-stack-using-queues/"},{"categories":[],"content":"二、题解 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode225-implement-stack-using-queues/:2:0","tags":[],"title":"LeetCode225题笔记","uri":"/zh-cn/notes/leetcode225-implement-stack-using-queues/"},{"categories":[],"content":"2.1 两个队列实现 操作图： 代码： type MyStack struct { q1 []int // 这里对应stack数据 q2 []int // 辅助的 } /** Initialize your data structure here. */ func Constructor() MyStack { return MyStack{ q1: []int{}, q2: []int{}, } } /** Push element x onto stack. */ func (this *MyStack) Push(x int) { this.q2 = append(this.q2, x) for i := 0; i \u003c len(this.q1); i++ { this.q2 = append(this.q2, this.q1[i]) } this.q1, this.q2 = this.q2, []int{} } /** Removes the element on top of the stack and returns that element. */ func (this *MyStack) Pop() int { r := this.Top() this.q1 = this.q1[1:] return r } /** Get the top element. */ func (this *MyStack) Top() int { return this.q1[0] } /** Returns whether the stack is empty. */ func (this *MyStack) Empty() bool { return len(this.q1) == 0 } 时间复杂度 – 入栈：$ O(n) $ 出栈 $ O(1) $ 空间复杂度 $ O(n) $ 成绩： 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 MB, 在所有 Go 提交中击败了68.06%的用户 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode225-implement-stack-using-queues/:2:1","tags":[],"title":"LeetCode225题笔记","uri":"/zh-cn/notes/leetcode225-implement-stack-using-queues/"},{"categories":[],"content":"2.2 一个队列实现 操作图： 代码： type MyStack struct { element []int } /** Initialize your data structure here. */ func Constructor() MyStack { return MyStack{ element: []int{}, } } /** Push element x onto stack. */ func (this *MyStack) Push(x int) { this.element = append(this.element, x) if len(this.element) \u003e 1 { // 拿出第一个，后面的往后移动 front := this.element[len(this.element)-1] for i := len(this.element) - 1; i \u003e 0; i-- { this.element[i] = this.element[i-1] } this.element[0] = front } } /** Removes the element on top of the stack and returns that element. */ func (this *MyStack) Pop() int { r := this.Top() this.element = this.element[1:] return r } /** Get the top element. */ func (this *MyStack) Top() int { return this.element[0] } /** Returns whether the stack is empty. */ func (this *MyStack) Empty() bool { return len(this.element) == 0 } 时间复杂度 – 入栈：$ O(n) $ 出栈 $ O(1) $ 空间复杂度 $ O(n) $，比双队列要省空间 成绩： 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 MB, 在所有 Go 提交中击败了100.00%的用户 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode225-implement-stack-using-queues/:2:2","tags":[],"title":"LeetCode225题笔记","uri":"/zh-cn/notes/leetcode225-implement-stack-using-queues/"},{"categories":[],"content":"2.3 发现 LeetCode 你不用队列也能通过 代码： type MyStack struct { element []int } /** Initialize your data structure here. */ func Constructor() MyStack { return MyStack{ element: []int{}, } } /** Push element x onto stack. */ func (this *MyStack) Push(x int) { this.element = append(this.element, x) } /** Removes the element on top of the stack and returns that element. */ func (this *MyStack) Pop() int { r := this.Top() this.element = this.element[:len(this.element)-1] return r } /** Get the top element. */ func (this *MyStack) Top() int { return this.element[len(this.element)-1] } /** Returns whether the stack is empty. */ func (this *MyStack) Empty() bool { if this.element != nil \u0026\u0026 len(this.element) \u003e 0 { return false } return true } 成绩： 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 MB, 在所有 Go 提交中击败了68.28%的用户 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode225-implement-stack-using-queues/:2:3","tags":[],"title":"LeetCode225题笔记","uri":"/zh-cn/notes/leetcode225-implement-stack-using-queues/"},{"categories":[],"content":"2.2 小结 题目和232比较类似，未想到实际项目场景 建议看看就好 本章的代码连接 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode225-implement-stack-using-queues/:2:4","tags":[],"title":"LeetCode225题笔记","uri":"/zh-cn/notes/leetcode225-implement-stack-using-queues/"},{"categories":[],"content":"一、题目 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/:1:0","tags":[],"title":"LeetCode232题笔记","uri":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/"},{"categories":[],"content":"1.1 题目说明 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 进阶： 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。 示例： 输入： [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] 输出： [null, null, null, 1, 1, false] 解释： MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false 提示： 1 \u003c= x \u003c= 9 最多调用 100 次 push、pop、peek 和 empty 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作） leetcode地址 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/:1:1","tags":[],"title":"LeetCode232题笔记","uri":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/"},{"categories":[],"content":"1.2 审题 概率可以查看之前的笔记 队列 栈 两个栈是关键，栈是先入后出，队列是先入先出，那么使用负负得正的思路去做，把元素在两个栈之间捣腾，图解如下： 使用栈来实现的队列，在出栈的时候如果发现输出栈的栈是空，那么需要有一步 move 的操作来把输入栈的内容出栈并向输出栈入栈。 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/:1:2","tags":[],"title":"LeetCode232题笔记","uri":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/"},{"categories":[],"content":"2、题解 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/:2:0","tags":[],"title":"LeetCode232题笔记","uri":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/"},{"categories":[],"content":"2.1 实现 代码： type MyQueue struct { in []int // 输入栈 out []int // 输出栈 } /** Initialize your data structure here. */ func Constructor() MyQueue { return MyQueue{ in: []int{}, out: []int{}, } } /** Push element x to the back of queue. */ func (this *MyQueue) Push(x int) { this.in = append(this.in, x) } /** Removes the element from in front of queue and returns that element. */ func (this *MyQueue) Pop() int { r := this.Peek() this.out = this.out[:len(this.out)-1] return r } /** Get the front element. */ func (this *MyQueue) Peek() int { if len(this.out) \u003e 0 { return this.out[len(this.out)-1] } if len(this.out) == 0 \u0026\u0026 len(this.in) \u003e 0 { this.move() } return this.Peek() } /** Returns whether the queue is empty. */ func (this *MyQueue) Empty() bool { return len(this.in)+len(this.out) == 0 } // 相当于从 in 出栈，到 out 入栈 func (this *MyQueue) move() { for i := len(this.in) - 1; i \u003e= 0; i-- { this.out = append(this.out, this.in[i]) } this.in = []int{} } 时间复杂度 – 入队：$ O(1) $ 出队：$ O(1) $，均摊的时间复杂度（最坏情况下的操作一旦发生了一次，那么在未来很长一段时间都不会再次发生，这样就会均摊每次操作的代价），简单的讲一个元素经历了（入栈，出栈，入栈，出栈），所以是稳定的时间复杂度。 空间复杂度 – 入队：$ O(n) $ 出队：$ O(1) $ 成绩： 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 MB, 在所有 Go 提交中击败了91.91%的用户 另一个写法： 其它的一种做法是在入队列的时候先捣腾好顺序，出队的时候就直接出就行了，这个会明显增加捣腾的次数，比如： 输入 1，2，3，4。s1，s2 分别是2个stack，比较简单也不画图了，直接看下面的抽象演变过程： 1|NULL ==》NULL|1 – 2|1 – 1/2|NULL ==\u003e NULL|2/1 – 3|2/1 – 1/2/3|NULL ==\u003e NULL|3/2/1 – 4|3/2/1 – 1/2/3/4|NULL step1 1入队s1 step2 1出队s1 1入队s2 2入队s1 1出队s2 1 入队s1 step3 1出队s1 1入队s2 2出队s1 2入队s2 3入队s1 2出队s2 2入队s1 1出队s2 1入队s1 step4 1出队s1 1入队s2 2出队s1 2入队s2 3出队s1 3入队s2 4入队s1 3出队s2 3入队s1 2出队s2 2入队s1 1出队s2 1入队s1 n越大，次数就越多，2n的移动数，所以时间复杂度会是 $ O(n) $。 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/:2:1","tags":[],"title":"LeetCode232题笔记","uri":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/"},{"categories":[],"content":"2.2 小结 题目比较简单，未想到实际项目场景 建议看看就好 本章的代码连接 ","date":"2020-01-24","objectID":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/:2:2","tags":[],"title":"LeetCode232题笔记","uri":"/zh-cn/notes/leetcode232-implement-queue-using-stacks/"},{"categories":[],"content":"一、题目 ","date":"2020-01-23","objectID":"/zh-cn/notes/leetcode20-valid-parentheses/:1:0","tags":[],"title":"LeetCode20题笔记","uri":"/zh-cn/notes/leetcode20-valid-parentheses/"},{"categories":[],"content":"1.1 题目说明 给定一个只包括 ‘('，')'，'{'，'}'，'['，']’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: \"()\" 输出: true 示例 2: 输入: \"()[]{}\" 输出: true 示例 3: 输入: \"(]\" 输出: false 示例 4: 输入: \"([)]\" 输出: false 示例 5: 输入: \"{[]}\" 输出: true leetcode地址 ","date":"2020-01-23","objectID":"/zh-cn/notes/leetcode20-valid-parentheses/:1:1","tags":[],"title":"LeetCode20题笔记","uri":"/zh-cn/notes/leetcode20-valid-parentheses/"},{"categories":[],"content":"1.2 题目知识点介绍 这道题目主要是考核堆栈这个数据结构，它是一个先进先出、操作受限的线性表，也称为 栈。 栈的两种基本的操作 入栈 push： 往栈中最顶端插入数据 出栈 pop： 从栈中删除最顶端的数据 栈的实现方式 数组实现，称为顺序栈 链表实现，称为链式栈 手动实现一个栈 ","date":"2020-01-23","objectID":"/zh-cn/notes/leetcode20-valid-parentheses/:1:2","tags":[],"title":"LeetCode20题笔记","uri":"/zh-cn/notes/leetcode20-valid-parentheses/"},{"categories":[],"content":"二、题解 ","date":"2020-01-23","objectID":"/zh-cn/notes/leetcode20-valid-parentheses/:2:0","tags":[],"title":"LeetCode20题笔记","uri":"/zh-cn/notes/leetcode20-valid-parentheses/"},{"categories":[],"content":"2.1 栈实现 代码： func isValid(s string) bool { var stack []byte pairs := map[byte]byte{ ')': '(', ']': '[', '}': '{', } for i := range s { if pairs[s[i]] \u003e 0 { // 这里如果没匹配到，是 byte 默认值 0 if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] { // 栈顶 Top() 匹配期望值 return false } stack = stack[:len(stack)-1] // 移除栈顶 Pop() } else { stack = append(stack, s[i]) } } return len(stack) == 0 } 时间复杂度 $ O(n) $ n 是字符串长度 空间复杂度 $ O(n+6) $ 因为这个题目中就 6 种扩展，空间就和栈中存放的数据有关，也就是和字符串长度有关 小优化： func isValid(s string) bool { if len(s)\u00261 == 1 { return false } var stack []byte pairs := map[byte]byte{ ')': '(', ']': '[', '}': '{', } for i := range s { if pairs[s[i]] \u003e 0 { // 这里如果没匹配到，是 byte 默认值 0 if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] { // 栈顶 Top() 匹配期望值 return false } stack = stack[:len(stack)-1] // 移除栈顶 Pop() } else { stack = append(stack, s[i]) } } return len(stack) == 0 } 如果是奇数肯定不可能是 true 成绩： 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 MB, 在所有 Go 提交中击败了91.93%的用户 栈的操作图： ","date":"2020-01-23","objectID":"/zh-cn/notes/leetcode20-valid-parentheses/:2:1","tags":[],"title":"LeetCode20题笔记","uri":"/zh-cn/notes/leetcode20-valid-parentheses/"},{"categories":[],"content":"2.2 非栈实现 代码： func isValid(s string) bool { var l int for ok := true; ok; ok = l != len(s) { l = len(s) s = strings.ReplaceAll(strings.ReplaceAll(strings.ReplaceAll(s, \"()\", \"\"), \"{}\", \"\"), \"[]\", \"\") } return len(s) == 0 } 平均时间复杂度是 $ O^2/2 $，字符串替换是 n，for 循环是 n，所以是 n 平方 虽然代码很精简，但是时间和空间复杂度的表现都不是很好 成绩： 执行用时：8 ms, 在所有 Go 提交中击败了7.18%的用户 内存消耗：7.1 MB, 在所有 Go 提交中击败了5.07%的用户 ","date":"2020-01-23","objectID":"/zh-cn/notes/leetcode20-valid-parentheses/:2:2","tags":[],"title":"LeetCode20题笔记","uri":"/zh-cn/notes/leetcode20-valid-parentheses/"},{"categories":[],"content":"2.3 小结 强烈建议使用栈来实现 栈的逻辑是：如果是左边括号就入栈，如果遇到右边括号就去查询栈顶元素，如果是与之匹配的左边括号的话就取出元素，否则就不匹配返回，执行到最后查看栈是否为空，空的话就是匹配的 记得对边界条件做处理，比如字符串长度是奇数的处理 空字符串也是满足的 本章的代码连接 ","date":"2020-01-23","objectID":"/zh-cn/notes/leetcode20-valid-parentheses/:2:3","tags":[],"title":"LeetCode20题笔记","uri":"/zh-cn/notes/leetcode20-valid-parentheses/"},{"categories":["设计模式"],"content":"本文介绍设计模式之模板方法模式","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"一、前言 Template Pattern 模板方法 来自 Wiki 百科的介绍： 模板方法模型是一种行为设计模型。模板方法是一个定义在父类别的方法，在模板方法中会呼叫多个定义在父类别的其他方法，而这些方法有可能只是抽象方法并没有实作，模板方法仅决定这些抽象方法的执行顺序，这些抽象方法的实作由子类别负责，并且子类别不允许覆写模板方法。 模板方法是属于设计模式的行为型模式 模板方法模式按照我的白话文理解： 首先定一个“抽象类”，它有一个模板方法A，定义可能需要子类实现的方法B，C，D…，然后在A方法里面编排好了B，C，D等的位置，当实现类调用A的时候，会调用各自实现的B，C，D方法（某些方法有默认实现，子类可以不实现），从而在一样的大流程里面进行不一样的操作。 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:1:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"二、简单实例 故事背景 阳光明媚的一天，玩码部落来了一群腿长一米八的MM，它们来自台湾，杭州及北京，她们将介绍各自家乡是如何准备丰富的晚餐的。 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:2:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"2.1 Java版本 2.1.1 定义接口 public interface Dinner { /** * 晚餐 */ void doDinner(); } 定义一个接口，就一个无参的 void 方法。 2.1.2 定义抽象方法 public abstract class AbstractDinner implements Dinner { protected String name; public AbstractDinner(String name) { this.name = name; } private void eat() { System.out.printf(\"%sMM说：开吃喽\", name).println(); } protected boolean foodEnough() { return true; } protected void doShopping() { System.out.println(\"门口小贩买菜\"); } protected abstract void beforeCooking(); protected abstract String doCooking(); protected abstract void afterCooking(); @Override public void doDinner() { if (!foodEnough()) { doShopping(); } beforeCooking(); System.out.println(doCooking()); afterCooking(); eat(); } } 定义 AbstractDinner 实现接口，它自身有五个方法，默认实现的 foodEnough 和 doShopping，以及抽象方法 beforeCooking、doCooking 和 afterCooking。 doDinner 编排了这些方法的流程或者说定义了各阶段的步骤。 2.1.3 定义实现类 public class BeijingDinner extends AbstractDinner { public BeijingDinner(String name) { super(name); } @Override protected void beforeCooking() { System.out.printf(\"%sMM 在洗菜切菜\", name).println(); } @Override protected String doCooking() { return name + \"MM 在做\" + name + \"菜\"; } @Override protected void afterCooking() { System.out.printf(\"%sMM 让你去品尝\", name).println(); } } public class TaiwanDinner extends AbstractDinner { public TaiwanDinner(String name) { super(name); } @Override protected boolean foodEnough() { // 每次都买食物 return false; } @Override protected void doShopping() { System.out.println(\"生鲜超市购买，一定要买茶叶蛋\"); } @Override protected void beforeCooking() { System.out.printf(\"%sMM 在洗菜切菜\", name).println(); } @Override protected String doCooking() { return name + \"MM 在做\" + name + \"菜\"; } @Override protected void afterCooking() { System.out.printf(\"%sMM 让你去品尝\", name).println(); } } public class HangzhouDinner extends AbstractDinner { public HangzhouDinner(String name) { super(name); } @Override protected boolean foodEnough() { // 每次都买食物 return false; } @Override protected void beforeCooking() { System.out.printf(\"%sMM 在洗菜切菜\", name).println(); } @Override protected String doCooking() { return name + \"MM 在做\" + name + \"菜\"; } @Override protected void afterCooking() { System.out.printf(\"%sMM 让你去品尝\", name).println(); } } 定义了三个实现类，都实现了3个抽象方法。另外 TaiwanDinner 重写了另外两个方法，HangzhouDinner 只重写了 foodEnough。 2.1.4 运行例子 代码： public class DinnerDemo { public static void main(String[] args) { System.out.println(\"---准备台湾餐---\"); Dinner dinner1 = new TaiwanDinner(); dinner1.doDinner(); System.out.println(\"---准备杭州餐---\"); Dinner dinner2 = new HangzhouDinner(); dinner2.doDinner(); System.out.println(\"---准备北京餐---\"); Dinner dinner3 = new BeijingDinner(); dinner3.doDinner(); } } 输出结果： ---准备台湾餐--- 生鲜超市购买，一定要买茶叶蛋 台湾MM 在洗菜切菜 台湾MM 在做台湾菜 台湾MM 让你去品尝 台湾MM说：开吃喽 ---准备杭州餐--- 门口小贩买菜 杭州MM 在洗菜切菜 杭州MM 在做杭州菜 杭州MM 让你去品尝 杭州MM说：开吃喽 ---准备北京餐--- 北京MM 在洗菜切菜 北京MM 在做北京菜 北京MM 让你去品尝 北京MM说：开吃喽 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:2:1","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"2.2 Golang 版本 声明下：在 golang 中，由于不存在抽象类和真正的继承，所以只能通过一个基础类来充当抽象类，子类通过组合基础类来实现通用方法的继承。 2.2.1 定义接口 type Dinner interface { DoDinner() } 2.2.2 定义抽象类 type AbstractCooking struct { foodEnough func() bool doShopping func() beforeCooking func() doCooking func() string afterCooking func() Name string } func (d *AbstractCooking) DoDinner() { if !d.foodEnough() { d.doShopping() } d.beforeCooking() fmt.Println(d.doCooking()) d.afterCooking() d.eat() } func (d *AbstractCooking) eat() { fmt.Println(fmt.Sprintf(\"%sMM说：开吃喽\", d.Name)) } 这里和 Java 不一样的地方是 go 的结构体可以拥有 func() 属性（也可以拥有接口属性）。 实现 Dinner 的方法 DoDinner , 编排了一系列的方法。 2.2.3 定义实现类 type HZDinner struct { AbstractCooking } func NewHZDinner(name string) *HZDinner { c := new(HZDinner) c.Name = name // 选择实现的 c.AbstractCooking.foodEnough = c.foodEnough c.AbstractCooking.doShopping = doShopping // 必须实现的 c.AbstractCooking.beforeCooking = c.beforeCooking c.AbstractCooking.doCooking = c.doCooking c.AbstractCooking.afterCooking = c.afterCooking return c } func (c *HZDinner) foodEnough() bool { return false } func (c *HZDinner) beforeCooking() { println(fmt.Printf(\"%sMM 在洗菜切菜\", c.Name)) } func (c *HZDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", c.Name, c.Name) } func (c *HZDinner) afterCooking() { println(fmt.Printf(\"%sMM 让你去品尝\", c.Name)) } type TWDinner struct { AbstractCooking } func NewTWDinner(name string) *TWDinner { c := new(TWDinner) c.Name = name // 选择实现的 c.AbstractCooking.foodEnough = c.foodEnough c.AbstractCooking.doShopping = c.doShopping // 必须实现的 c.AbstractCooking.beforeCooking = c.beforeCooking c.AbstractCooking.doCooking = c.doCooking c.AbstractCooking.afterCooking = c.afterCooking return c } func (c *TWDinner) foodEnough() bool { return false } func (c *TWDinner) doShopping() { fmt.Println(\"生鲜超市购买，一定要买茶叶蛋\") } func (c *TWDinner) beforeCooking() { println(fmt.Printf(\"%sMM 在洗菜切菜\", c.Name)) } func (c *TWDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", c.Name, c.Name) } func (c *TWDinner) afterCooking() { println(fmt.Printf(\"%sMM 让你去品尝\", c.Name)) } type BJDinner struct { AbstractCooking } func NewBJDinner(name string) *BJDinner { c := new(BJDinner) c.Name = name // 选择实现的 c.AbstractCooking.foodEnough = foodEnough c.AbstractCooking.doShopping = doShopping // 必须实现的 c.AbstractCooking.beforeCooking = c.beforeCooking c.AbstractCooking.doCooking = c.doCooking c.AbstractCooking.afterCooking = c.afterCooking return c } func (c *BJDinner) beforeCooking() { println(fmt.Printf(\"%sMM 在洗菜切菜\", c.Name)) } func (c *BJDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", c.Name, c.Name) } func (c *BJDinner) afterCooking() { println(fmt.Printf(\"%sMM 让你去品尝\", c.Name)) } 2.2.4 定义默认实现方法 func foodEnough() bool { return true } func doShopping() { fmt.Println(\"门口小贩买菜\") } 为什么有独立的默认方法，因为 struct 里面定义了 foodEnough() bool 和 doShopping() 两个方法，go 里面是不能重名的，因此不能再写属于 AbstractCooking 的方法。 func (d *AbstractCooking) foodEnough() bool { return true } 这个方法如何写了，去掉了 struct 的 foodEnough() bool，那么创建实现类的时候就没办法 c.AbstractCooking.foodEnough = c.foodEnough 进行 func() 赋值，从而 d.foodEnough() 会一直调用 AbstractCooking 下的 foodEnough()，实现类没办法自定义实现了。 2.2.5 运行例子 代码： func TestTemplate1(t *testing.T) { fmt.Println(\"---准备台湾餐---\") d1 := NewTWDinner(\"台湾\") d1.DoDinner() fmt.Println(\"---准备杭州餐---\") d2 := NewHZDinner(\"杭州\") d2.DoDinner() fmt.Println(\"---准备北京餐---\") d3 := NewBJDinner(\"北京\") d3.DoDinner() } 输出结果： ---准备台湾餐--- 生鲜超市购买，一定要买茶叶蛋 台湾MM 在洗菜切菜 台湾MM 在做台湾菜 台湾MM 让你去品尝 台湾MM说：开吃喽 ---准备杭州餐--- 门口小贩买菜 杭州MM 在洗菜切菜 杭州MM 在做杭州菜 杭州MM 让你去品尝 杭州MM说：开吃喽 ---准备北京餐--- 北京MM 在洗菜切菜 北京MM 在做北京菜 北京MM 让你去品尝 北京MM说：开吃喽 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:2:2","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"2.3 Golang版本2 上面例子是在 struct 中定义，相当于是抽象方法的意思，而这版本把那部分方法都定义到了接口。 2.3.1 定义接口 type Dinner2 interface { foodEnough() bool doShopping() beforeCooking() doCooking() string afterCooking() } 2.3.2 定义抽象类 type AbstractDinner struct { } func (AbstractDinner) foodEnough() bool { return true } func (AbstractDinner) doShopping() { fmt.Println(\"门口小贩买菜\") } func (AbstractDinner) beforeCooking() { } func (AbstractDinner) doCooking() string { return \"\" } func (AbstractDinner) afterCooking() { } 实现 Dinner2 接口，和下面等价 type AbstractDinner struct { Dinner2 } func (AbstractDinner) foodEnough() bool { return true } func (AbstractDinner) doShopping() { fmt.Println(\"门口小贩买菜\") } 2.3.3 定义实现类 type HangzhouDinner struct { AbstractDinner } func NewHangzhouDinner(name string) Dinner2 { return \u0026HangzhouDinner{ AbstractDinner{ Name: name, }, } } func (d *HangzhouDinner) foodEnough() bool { return false } func (d *HangzhouDinner) beforeCooking() { fmt.Println(fmt.Sprintf(\"%sMM 在洗菜切菜\", d.Name)) } func (d *HangzhouDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", d.Name, d.Name) } func (d *HangzhouDinner) afterCooking() { fmt.Println(fmt.Sprintf(\"%sMM 让你去品尝\", d.Name)) } type BeijingDinner struct { AbstractDinner } func NewBeijingDinner(name string) Dinner2 { return \u0026BeijingDinner{ AbstractDinner{ Name: name, }, } } func (d *BeijingDinner) beforeCooking() { fmt.Println(fmt.Sprintf(\"%sMM 在洗菜切菜\", d.Name)) } func (d *BeijingDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", d.Name, d.Name) } func (d *BeijingDinner) afterCooking() { fmt.Println(fmt.Sprintf(\"%sMM 让你去品尝\", d.Name)) } type TaiwanDinner struct { AbstractDinner } func NewTaiwanDinner(name string) Dinner2 { return \u0026TaiwanDinner{ AbstractDinner{ Name: name, }, } } func (d *TaiwanDinner) foodEnough() bool { return false } func (d *TaiwanDinner) doShopping() { fmt.Println(\"生鲜超市购买，一定要买茶叶蛋\") } func (d *TaiwanDinner) beforeCooking() { fmt.Println(fmt.Sprintf(\"%sMM 在洗菜切菜\", d.Name)) } func (d *TaiwanDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", d.Name, d.Name) } func (d *TaiwanDinner) afterCooking() { fmt.Println(fmt.Sprintf(\"%sMM 让你去品尝\", d.Name)) } 2.3.4 定义模板方法 func DoDinner(d Dinner2) { if !d.foodEnough() { d.doShopping() } d.beforeCooking() fmt.Println(d.doCooking()) d.afterCooking() d.eat() } func (ad AbstractDinner) eat() { fmt.Println(fmt.Sprintf(\"%sMM说：开吃喽\", ad.Name)) } 如果想把抽象方法放到结构体上，也可以如下： type Dinner2 interface { ... DoDinner(d Dinner2) } func (ad AbstractDinner) DoDinner(d Dinner2) { if !d.foodEnough() { d.doShopping() } d.beforeCooking() fmt.Println(d.doCooking()) d.afterCooking() ad.eat() } func (ad AbstractDinner) eat() { fmt.Println(fmt.Sprintf(\"%sMM说：开吃喽\", ad.Name)) } 到时候调用的话就 DoDinner 改成 d1 := NewTaiwanDinner(\"台湾\") d1.DoDinner(d1)。 2.3.5 运行例子 代码： func TestTemplate2(t *testing.T) { fmt.Println(\"---准备台湾餐---\") d1 := NewTaiwanDinner(\"台湾\") DoDinner(d1) fmt.Println(\"---准备杭州餐---\") d2 := NewHangzhouDinner(\"杭州\") DoDinner(d2) fmt.Println(\"---准备北京餐---\") d3 := NewTaiwanDinner(\"北京\") DoDinner(d3) } 输出结果： ---准备台湾餐--- 生鲜超市购买，一定要买茶叶蛋 台湾MM 在洗菜切菜 台湾MM 在做台湾菜 台湾MM 让你去品尝 台湾MM说：开吃喽 ---准备杭州餐--- 门口小贩买菜 杭州MM 在洗菜切菜 杭州MM 在做杭州菜 杭州MM 让你去品尝 杭州MM说：开吃喽 ---准备北京餐--- 生鲜超市购买，一定要买茶叶蛋 北京MM 在洗菜切菜 北京MM 在做北京菜 北京MM 让你去品尝 北京MM说：开吃喽 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:2:3","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"2.4、例子说明 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:2:4","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"三、开源框架使用场景 列举某几个框架，供大家参考 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:3:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"3.1 JDK AbstractList public abstract class AbstractList\u003cE\u003e extends AbstractCollection\u003cE\u003e implements List\u003cE\u003e { ... public void add(int index, E element) { throw new UnsupportedOperationException(); } ... public boolean addAll(int index, Collection\u003c? extends E\u003e c) { rangeCheckForAdd(index); boolean modified = false; for (E e : c) { add(index++, e); modified = true; } return modified; } ... } 实现类实现 add 的逻辑，如： public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable { // ... public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } // ... } ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:3:1","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"3.1 spring 中的 事务管理器 public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable { // ... public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException { Object transaction = doGetTransaction(); // Cache debug flag to avoid repeated checks. boolean debugEnabled = logger.isDebugEnabled(); if (definition == null) { // Use defaults if no transaction definition given. definition = new DefaultTransactionDefinition(); } if (isExistingTransaction(transaction)) { // Existing transaction found -\u003e check propagation behavior to find out how to behave. return handleExistingTransaction(definition, transaction, debugEnabled); } // Check definition settings for new transaction. if (definition.getTimeout() \u003c TransactionDefinition.TIMEOUT_DEFAULT) { throw new InvalidTimeoutException(\"Invalid transaction timeout\", definition.getTimeout()); } // No existing transaction found -\u003e check propagation behavior to find out how to proceed. if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) { throw new IllegalTransactionStateException( \"No existing transaction found for transaction marked with propagation 'mandatory'\"); } else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED || definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW || definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) { SuspendedResourcesHolder suspendedResources = suspend(null); if (debugEnabled) { logger.debug(\"Creating new transaction with name [\" + definition.getName() + \"]: \" + definition); } try { boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); doBegin(transaction, definition); prepareSynchronization(status, definition); return status; } catch (RuntimeException ex) { resume(null, suspendedResources); throw ex; } catch (Error err) { resume(null, suspendedResources); throw err; } } else { // Create \"empty\" transaction: no actual transaction, but potentially synchronization. if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT \u0026\u0026 logger.isWarnEnabled()) { logger.warn(\"Custom isolation level specified but no actual transaction initiated; \" + \"isolation level will effectively be ignored: \" + definition); } boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS); return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null); } } // ... protected abstract void doBegin(Object transaction, TransactionDefinition definition) throws TransactionException; ... } 这里只拿 getTransaction 和 doBegin 举例，非常标准的写法 getTransaction 还用了 final 描述，表示子类不允许改变。 当我自定义事务管理器的时候，比如每次事务开启创建一个 traceId，效果如下： public class GongDaoDataSourceTransactionManager extends DataSourceTransactionManager implements ResourceTransactionManager, InitializingBean, EnvironmentAware { // ... protected void doBegin(Object transaction, TransactionDefinition definition) { String currentXid; if (XIDContext.getCurrent() != null \u0026\u0026 null != XIDContext.getCurrent().getId()) { currentXid = xidGenerator.getXID(); XIDContext.childCurrent(new TransactionContent(currentXid, definition.getName())); } else { currentXid = xidGenerator.getXID(); XIDContext.setXid(new TransactionContent(currentXid, definition.getName())); } if (null == HyjalTransactionFileAppender.contextHolder.get()) { String logFileName = HyjalTransactionFileAppender.makeLogFileName(new Date(), HyjalTransactionFileAppender.logId.get()); HyjalTransactionFileAppender.contextHolder.set(logFileName); } try { if (null == XIDContext.getCurrentXid()) { XIDContext.setXid(xidGenerator.getXID()); } super.doBegin(transaction, definition); } finally { if (logger.isDebugEnabled()) { logger.debug(\"do begin Xi","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:3:2","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"四、优势和劣势 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:4:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"4.1 优势 对扩展开放，对修改关闭，符合“开闭原则” 定义标准算法，子类可自定义扩展，把变性和不变性分离 子类的扩展不会导致标准算法结构 能够提高代码复用，公共部分易维护 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:4:1","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"4.2 劣势 每一个实现类都需要定义自己的行为，如果复杂业务实现类会膨胀的比较多 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:4:2","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"},{"categories":["设计模式"],"content":"五、参考 https://www.tutorialspoint.com/design_pattern/template_pattern.htm https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95 ","date":"2019-11-09","objectID":"/zh-cn/2019/11/09/design-template/:5:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/2019/11/09/design-template/"}]