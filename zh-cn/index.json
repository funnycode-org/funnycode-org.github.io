[{"categories":["go源码"],"content":"本文是 map 源码系列第一篇，带你走进 map 为什么分析map 在计算机编程语言当中，用的最多的数据结构估计就是map。map以他近乎o(1)的查找效率和修改效率让他在大多数场景下都比较受青睐。map的常规的实现方式都是hash+其他数据结构，如java是hash+红黑树，而我现在即将要分析的go的实现方式是hash+链表。我会分析map的几乎每段代码，并且在我的GitHub可以查看到我的分析，注释十分详尽，欢迎批评指正。我的打算是把一些常用的数据结构都分析一遍，如果有志同道合的人，可以联系我。 ","date":"2020-11-25","objectID":"/zh-cn/go-sourcecode-map-first/:0:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"我的环境 为了给那些感兴趣看源码分析我的博客的同学阅读得更加清晰，列举了我的环境： go1.14.7 amd64； windows和mac接口，linux没有测试，估计没问题 ； goland,目前最好的golang ide，虽然笔者用起来感觉还是不太完美； 着重分析map[string]string，其他类型的源码变化不大 ； ","date":"2020-11-25","objectID":"/zh-cn/go-sourcecode-map-first/:1:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"本篇重点 1.go的map和java的map有区别，go中是一个关键字，而java确实可以直接查看源码，那么如何分析go的map源码？ 2.调试过程当中，go充斥着大量指针，如何知道指针指向的内容？map的最小单位bmap除了查看tophash，怎么查看里面的其他隐藏字段？ 3.go的map源码为何给不同的key的类型设计不同的实现？ 4.其他一些查看源码的小技巧：内存对齐、指针偏移、类型大小等等 ","date":"2020-11-25","objectID":"/zh-cn/go-sourcecode-map-first/:2:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"如何找到map对应的源码 go的map的结构体是hmap，代码位于runtime/map.go,当编译器编译你申明使用map的源码时候，其实是使用了runtime/map*.go,后面对map的增删改查都是执行该代码，故要弄懂map的底层原理只需要分析该源码，也可以断点调试。 我下面有个自己测试的源码，注意我编译之后查看，就可以发现端倪： package main import \"fmt\" func main() { m1 := make(map[string]string) fmt.Println(m1) m2 := make(map[string]string, 8) fmt.Println(m2) m3 := make(map[string]string, 9) fmt.Println(m3) m4 := map[string]string{} fmt.Println(m4) m3[\"1\"] = \"2\" for k, v := range m3 { fmt.Println(k) fmt.Println(v) } v1 := m3[\"1\"] fmt.Println(v1) if v2, ok := m3[\"1\"]; ok { fmt.Println(v2) } } 上面代码有几种不同申明map的方式，对应runtime/map.go也不同。还有赋值和遍历查找的代码。 下面编译得到汇编指令文件，执行 go tool compile -N -l -S main.go \u003e main.txt 生成了汇编指令文件: \"\".main STEXT size=1891 args=0x0 locals=0x288 0x0000 00000 (main.go:5) TEXT \"\".main(SB), ABIInternal, $648-0 0x0000 00000 (main.go:5) MOVQ TLS, CX 0x0009 00009 (main.go:5) PCDATA $0, $-2 0x0009 00009 (main.go:5) MOVQ (CX)(TLS*2), CX 0x0010 00016 (main.go:5) PCDATA $0, $-1 0x0010 00016 (main.go:5) LEAQ -520(SP), AX 0x0018 00024 (main.go:5) CMPQ AX, 16(CX) 0x001c 00028 (main.go:5) PCDATA $0, $-2 0x001c 00028 (main.go:5) JLS 1881 0x0022 00034 (main.go:5) PCDATA $0, $-1 0x0022 00034 (main.go:5) SUBQ $648, SP 0x0029 00041 (main.go:5) MOVQ BP, 640(SP) 0x0031 00049 (main.go:5) LEAQ 640(SP), BP 0x0039 00057 (main.go:5) PCDATA $0, $-2 0x0039 00057 (main.go:5) PCDATA $1, $-2 0x0039 00057 (main.go:5) FUNCDATA $0, gclocals·ad6397d3d33bbb6a31b1320349e23274(SB) 0x0039 00057 (main.go:5) FUNCDATA $1, gclocals·1bbf1965a34fa71a63e073b1cf2d752a(SB) 0x0039 00057 (main.go:5) FUNCDATA $2, gclocals·658035074399f748be6dd39603d5113c(SB) 0x0039 00057 (main.go:5) FUNCDATA $3, \"\".main.stkobj(SB) 0x0039 00057 (main.go:6) PCDATA $0, $0 0x0039 00057 (main.go:6) PCDATA $1, $0 0x0039 00057 (main.go:6) CALL runtime.makemap_small(SB) 0x003e 00062 (main.go:6) PCDATA $0, $1 0x003e 00062 (main.go:6) MOVQ (SP), AX 0x0042 00066 (main.go:6) MOVQ AX, \"\".m1+80(SP) 0x0047 00071 (main.go:7) PCDATA $0, $0 0x0047 00071 (main.go:7) PCDATA $1, $1 0x0047 00071 (main.go:7) MOVQ AX, \"\"..autotmp_10+200(SP) 0x004f 00079 (main.go:7) PCDATA $1, $2 0x004f 00079 (main.go:7) XORPS X0, X0 0x0052 00082 (main.go:7) MOVUPS X0, \"\"..autotmp_9+272(SP) 0x005a 00090 (main.go:7) PCDATA $0, $1 0x005a 00090 (main.go:7) PCDATA $1, $1 0x005a 00090 (main.go:7) LEAQ \"\"..autotmp_9+272(SP), AX 0x0062 00098 (main.go:7) MOVQ AX, \"\"..autotmp_15+192(SP) 0x006a 00106 (main.go:7) TESTB AL, (AX) 0x006c 00108 (main.go:7) PCDATA $0, $2 0x006c 00108 (main.go:7) PCDATA $1, $0 0x006c 00108 (main.go:7) MOVQ \"\"..autotmp_10+200(SP), CX 0x0074 00116 (main.go:7) PCDATA $0, $3 0x0074 00116 (main.go:7) LEAQ type.map[string]string(SB), DX 0x007b 00123 (main.go:7) PCDATA $0, $2 0x007b 00123 (main.go:7) MOVQ DX, \"\"..autotmp_9+272(SP) 0x0083 00131 (main.go:7) PCDATA $0, $1 0x0083 00131 (main.go:7) MOVQ CX, \"\"..autotmp_9+280(SP) 0x008b 00139 (main.go:7) TESTB AL, (AX) 0x008d 00141 (main.go:7) JMP 143 0x008f 00143 (main.go:7) MOVQ AX, \"\"..autotmp_14+520(SP) 0x0097 00151 (main.go:7) MOVQ $1, \"\"..autotmp_14+528(SP) 0x00a3 00163 (main.go:7) MOVQ $1, \"\"..autotmp_14+536(SP) 0x00af 00175 (main.go:7) PCDATA $0, $0 0x00af 00175 (main.go:7) MOVQ AX, (SP) 0x00b3 00179 (main.go:7) MOVQ $1, 8(SP) 0x00bc 00188 (main.go:7) MOVQ $1, 16(SP) 0x00c5 00197 (main.go:7) CALL fmt.Println(SB) 0x00ca 00202 (main.go:8) CALL runtime.makemap_small(SB) 0x00cf 00207 (main.go:8) PCDATA $0, $1 0x00cf 00207 (main.go:8) MOVQ (SP), AX 0x00d3 00211 (main.go:8) MOVQ AX, \"\".m2+72(SP) 0x00d8 00216 (main.go:9) PCDATA $0, $0 0x00d8 00216 (main.go:9) PCDATA $1, $1 0x00d8 00216 (main.go:9) MOVQ AX, \"\"..autotmp_10+200(SP) 0x00e0 00224 (main.go:9) PCDATA $1, $2 0x00e0 00224 (main.go:9) XORPS X0, X0 0x00e3 00227 (main.go:9) MOVUPS X0, \"\"..autotmp_9+272(SP) 0x00eb 00235 (main.go:9) PCDATA $0, $1 0x00eb 00235 (main.go:9) PCDATA $1, $1 0x00eb 00235 (main.go:9) LEAQ \"\"..autotmp_9+272(SP), AX 0x00f3 00243 (main.go:9) MOVQ AX, \"\"..autotmp_17+184(SP) 0x00fb 00251 (main.go:9) TESTB AL, (AX) 0x00fd 00253 (main.go:9) PCDATA $0,","date":"2020-11-25","objectID":"/zh-cn/go-sourcecode-map-first/:3:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"go的map对应的结构体hmap go的map的基础结构体是hmap,在runtime/map.go中， // A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler's definition. // map存储的键值对个数 count int // # live cells == size of map. Must be first (used by len() builtin) // 表示map的一些标志位 flags uint8 // map的桶的2的对数就是B值 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) // 溢出桶个数，是个近似数，不完全相等 noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details // hash种子 hash0 uint32 // hash seed // 桶，真正存数据的地方，2^B个桶 buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. // 保存一些即将迁移的桶 oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing // 从oldbuckets迁移到新的buckets的进度 nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) // 当key不是指针类型的数据的时候，里面会存溢出桶，这样会避免go的扫描 extra *mapextra // optional fields } 既然是map结构体，为何注释说是一个header呢？这是因为buckets和oldbuckets这2个字段并没有真正存取数据，只是存了一个指针，指向存取buckets的地址，故我们在使用过程中拷贝hmap的时候，并没有真正拷贝map的数据，只是拷贝了hmap这个结构体的一些数据。 在看看hmap的字段mapextra: // mapextra holds fields that are not present on all maps. type mapextra struct { // If both key and elem do not contain pointers and are inline, then we mark bucket // 如果key和value都不包括指针并且内敛，然后我们就标记bucket没有指针 // type as containing no pointers. This avoids scanning such maps. // 这样会避免gc扫描 // However, bmap.overflow is a pointer. In order to keep overflow buckets // 但是，虽然key和value不包括指针，但是逸出桶却是个指针，为了让逸出桶一直 // alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow. // 存在，所以就把逸出桶和需要迁移的逸出桶的指针存到hamp的extra字段里面 // overflow and oldoverflow are only used if key and elem do not contain pointers. // 如果key和elme包含指针，overflow和oldoverflow就不会被使用了 // overflow contains overflow buckets for hmap.buckets. // oldoverflow contains overflow buckets for hmap.oldbuckets. // The indirection allows to store a pointer to the slice in hiter. overflow *[]*bmap oldoverflow *[]*bmap // nextOverflow holds a pointer to a free overflow bucket. nextOverflow *bmap } 如mapextra结构体为啥说有些字段并不会在所有map里面全部都有呢？mapextra是一个为了优化bucket而设计的，当key或value是指针的时候，此时overflow和oldoverflow就不会被使用，只有nextOverflow会被使用，该字段保存了预先申请的逸出桶，在没有发生扩容的时候，而一个桶或者说bmap的8个tophash都被使用完了，那么就要考虑使用逸出桶。 当key和value都没有指针的时候bucket的bmap的_type的ptrdata就是0，意味着该结构体是没有指针的，申请bmap内存的时候，会申请一个没有指针的span，这样会避免gc扫描该内存，会提高效率，但是bmap的最后一个内存块是确确实实存放指针的，所以用uintptr存储着该map的逸出桶的地址，但是由于没有指向下一个逸出桶，可能会被gc回收掉，所以就需要overflow存取指向该逸出桶的指针避免被gc回收掉。 overflow和oldoverflow的用处差不多，只是oldoverflow为了迁移使用，后面的系列会详说。 ","date":"2020-11-25","objectID":"/zh-cn/go-sourcecode-map-first/:4:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"bucket的结构体bmap bmap就是真正存数据的结构体了,bmap在源码中定义十分简单： // A bucket for a Go map. type bmap struct { // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] \u003c minTopHash, // tophash[0] is a bucket evacuation state instead. tophash [bucketCnt]uint8 // Followed by bucketCnt keys and then bucketCnt elems. // NOTE: packing all the keys together and then all the elems together makes the // code a bit more complicated than alternating key/elem/key/elem/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer. } 但其实真正的在内存中分配的结构体是这样的： // A bucket for a Go map. type bmap struct { // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] \u003c minTopHash, // tophash[0] is a bucket evacuation state instead. tophash [bucketCnt]uint8 keys [bucketCnt]string // 由于我举例的key是string，故我这里写string values [bucketCnt]string // 由于上面我的例子的value的类型是string，故这里也是string pointer unsafe.pointer // 由于key和value都是指针，所以这里是一个指针 // Followed by bucketCnt keys and then bucketCnt elems. // NOTE: packing all the keys together and then all the elems together makes the // code a bit more complicated than alternating key/elem/key/elem/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer. } 隐藏的字段在map源码中都是靠地址偏移来得到，tophash我们能轻易找到位置，但是如何找到keys、values和pointer呢？ 在map中是这么做的： dataOffset = unsafe.Offsetof(struct { b bmap v int64 }{}.v) 在64位机器上，需要对齐8个字节，这里int64正好也是8个字节，所以恰好解决内存对齐的问题，找到v的起始地址也就是values的起始地址: dataOffset+bucketCnt*2*sys.PtrSize // string16个字节，相当于2个指针，bucketCnt等于8 pointer的起始地址 dataOffset+bucketCnt*2*sys.PtrSize+sys.PtrSize tophash存的是key的hash高8位，为了方便查找key，为什么keys和values分别存在一堆呢？不是k|v|k|v这种呢？由于key和value的变量类型可能不一样，对齐系数不一致，可能导致内存不紧凑而浪费内存，所以把8个keys存到一堆，8个values存到一堆，然后最后在pointer之前对齐就可以了。所以此时也能算出来整个bmap的大小: bucketCnt*(uint8的字节为1)+bucketCnt*(string的字节16)+bucketCnt*(string的字节16)+指针大小8字节 = 272 在真正调试的时候如查看bucket里面的具体的key和value呢？这里给大家展示一个小技巧，如果大家有其他方法，可以留言讨论： type dmap struct { tophash [bucketCnt]uint8 debugKeys [bucketCnt]string debugElems [bucketCnt]string //debugOverflows unsafe.Pointer debugOverflows uintptr } 这是我定义的调试结构体，将该代码和bmap的结构体放到一堆，当你获取到bmap桶的地址的时候，就可以如下转换，就可以查看bmap的具体值了： b0 := (*dmap)(add(buckets, uintptr(0)*uintptr(t.bucketsize))) println(b0.debugOverflows) buckets假设是桶数组的起始地址，加上bucketsize就会得到第二个桶的起始地址，然后直接转型为*dmap,最后你可以可以打印出来你想查看的真实的值了。 ","date":"2020-11-25","objectID":"/zh-cn/go-sourcecode-map-first/:5:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"map的整体结构 如果申请内存桶的时候又多余的溢出桶，那么mapextra的nextOverflow就会指向[]bmap其中的某块桶的地址，地址后之后的桶都是溢出桶。在一个桶装不下的时候，会去溢出桶拿桶然后bmap的overflow指向溢出桶。 ","date":"2020-11-25","objectID":"/zh-cn/go-sourcecode-map-first/:6:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/go-sourcecode-map-first/"},{"categories":["go源码"],"content":"总结 上面大概介绍了map的数据结构，后面系列map的具体代码分析，包括增、删、改、查、扩容等都会分篇细解，如有不足之处，请共同讨论学习。 ","date":"2020-11-25","objectID":"/zh-cn/go-sourcecode-map-first/:7:0","tags":["map"],"title":"go基础之map | 写在前面（一） ","uri":"/zh-cn/go-sourcecode-map-first/"},{"categories":["Hugo"],"content":"本文介绍如何使 Hugo 博客在 GitHub 自动部署","date":"2020-06-11","objectID":"/zh-cn/hugo-github-action/","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/hugo-github-action/"},{"categories":["Hugo"],"content":"一、前言 使用 Hugo 有一些时间了，把内容上传到 GitHub Pages，从一开始的手动操作，到脚本操作，终于来到了自动化部署。 部署的流程： 本地通过 Hugo 命令创建文件，编写博客，编写好后把改变的内容上传到 GitHub 博客源文件仓库。通过 GitHub Action 自动触发脚本构建，然后把静态文件通过 GitHub Deploy 到博客仓库。 ","date":"2020-06-11","objectID":"/zh-cn/hugo-github-action/:1:0","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/hugo-github-action/"},{"categories":["Hugo"],"content":"二、具体步骤 ","date":"2020-06-11","objectID":"/zh-cn/hugo-github-action/:2:0","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/hugo-github-action/"},{"categories":["Hugo"],"content":"2.1 创建两个仓库 创建博客源仓库 创建博客静态资源仓库 ","date":"2020-06-11","objectID":"/zh-cn/hugo-github-action/:2:1","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/hugo-github-action/"},{"categories":["Hugo"],"content":"2.2 创建 SSH 需要生成一对 SSH Key，生成的 Public Key 和 Private Key 都会用到。 ssh-keygen -t rsa -b 4096 -C \"ironcity.hz@gmail.com\" Generating public/private rsa key pair. Enter file in which to save the key (/Users/tc/.ssh/id_rsa): 输入你需要指定的文件，比如 /Users/tc/.ssh/id_rsa_hugo_deploy 只是为了防止覆盖之前创建的默认文件 ","date":"2020-06-11","objectID":"/zh-cn/hugo-github-action/:2:2","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/hugo-github-action/"},{"categories":["Hugo"],"content":"2.2 配置博客静态资源仓库的 Deploy Keys 添加公钥到 funnycode-org.github.io 仓库的 Deploy Keys 添加后 ","date":"2020-06-11","objectID":"/zh-cn/hugo-github-action/:2:3","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/hugo-github-action/"},{"categories":["Hugo"],"content":"2.3 配置博客源内容仓库的 Secrets 添加私钥到 blog 仓库的 Secrets 添加后 注意这个 secrets 的名称 ","date":"2020-06-11","objectID":"/zh-cn/hugo-github-action/:2:4","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/hugo-github-action/"},{"categories":["Hugo"],"content":"2.4 编写博客 克隆 blog 项目到本地 # 选取一个目录 cd ~/Desktop/ # 克隆 source 仓库 git clone git@github.com:funnycode-org/blog.git # 进入仓库 cd blog 创建 hugo 博客 # 创建博客，多语言模式 hugo new /posts/[blog-name]/index.zh-cn.md # 运行预览效果 hugo serve -D 如果没有什么问题就可以准备提交代码了 git add . git commit -m \"update commit\" git push -u origin master ","date":"2020-06-11","objectID":"/zh-cn/hugo-github-action/:2:5","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/hugo-github-action/"},{"categories":["Hugo"],"content":"2.5 GitHub Actions 说明 Actions 内容： name: Deploy Hugo Site to Github Pages on Master Branch on: push: branches: - master jobs: build-deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: '0.76.0' # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: funnycode-org/funnycode-org.github.io # remote branch publish_dir: \"./docs\" keep_files: false # remove existing files publish_branch: docs # deploying branch commit_message: ${{ github.event.head_commit.message }} 注意点： publish_dir 指定发布的目录，./docs 指 blog 项目下的 docs 目录下的内容会被发布 publish_branch 发布到 funnycode-org.github.io 项目的 docs 分支 secrets.ACTIONS_DEPLOY_KEY 的 ACTIONS_DEPLOY_KEY 则是上面设置 Private Key 的变量名 ","date":"2020-06-11","objectID":"/zh-cn/hugo-github-action/:2:6","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/hugo-github-action/"},{"categories":["Hugo"],"content":"2.7 funnycode-org.github.io 配置 配置 Setting 验证访问 输入 ![https://blog.funnycode.org.cn] (https://blog.funnycode.org.cn)，效果： ","date":"2020-06-11","objectID":"/zh-cn/hugo-github-action/:2:7","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/hugo-github-action/"},{"categories":["Hugo"],"content":"三、参考 https://github.com/peaceiris/actions-hugo https://zhuanlan.zhihu.com/p/109057290 ","date":"2020-06-11","objectID":"/zh-cn/hugo-github-action/:3:0","tags":["github","action"],"title":"Hugo 白话文 | GitHub Action 自动部署","uri":"/zh-cn/hugo-github-action/"},{"categories":["设计模式"],"content":"本文介绍设计模式之模板方法模式","date":"2019-11-09","objectID":"/zh-cn/design-template/","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/design-template/"},{"categories":["设计模式"],"content":"一、前言 Template Pattern 模板方法 来自 Wiki 百科的介绍： 模板方法模型是一种行为设计模型。模板方法是一个定义在父类别的方法，在模板方法中会呼叫多个定义在父类别的其他方法，而这些方法有可能只是抽象方法并没有实作，模板方法仅决定这些抽象方法的执行顺序，这些抽象方法的实作由子类别负责，并且子类别不允许覆写模板方法。 模板方法是属于设计模式的行为型模式 模板方法模式按照我的白话文理解： 首先定一个“抽象类”，它有一个模板方法A，定义可能需要子类实现的方法B，C，D…，然后在A方法里面编排好了B，C，D等的位置，当实现类调用A的时候，会调用各自实现的B，C，D方法（某些方法有默认实现，子类可以不实现），从而在一样的大流程里面进行不一样的操作。 ","date":"2019-11-09","objectID":"/zh-cn/design-template/:1:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/design-template/"},{"categories":["设计模式"],"content":"二、简单实例 故事背景 阳光明媚的一天，玩码部落来了一群腿长一米八的MM，它们来自台湾，杭州及北京，她们将介绍各自家乡是如何准备丰富的晚餐的。 ","date":"2019-11-09","objectID":"/zh-cn/design-template/:2:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/design-template/"},{"categories":["设计模式"],"content":"2.1 Java版本 2.1.1 定义接口 public interface Dinner { /** * 晚餐 */ void doDinner(); } 定义一个接口，就一个无参的 void 方法。 2.1.2 定义抽象方法 public abstract class AbstractDinner implements Dinner { protected String name; public AbstractDinner(String name) { this.name = name; } private void eat() { System.out.printf(\"%sMM说：开吃喽\", name).println(); } protected boolean foodEnough() { return true; } protected void doShopping() { System.out.println(\"门口小贩买菜\"); } protected abstract void beforeCooking(); protected abstract String doCooking(); protected abstract void afterCooking(); @Override public void doDinner() { if (!foodEnough()) { doShopping(); } beforeCooking(); System.out.println(doCooking()); afterCooking(); eat(); } } 定义 AbstractDinner 实现接口，它自身有五个方法，默认实现的 foodEnough 和 doShopping，以及抽象方法 beforeCooking、doCooking 和 afterCooking。 doDinner 编排了这些方法的流程或者说定义了各阶段的步骤。 2.1.3 定义实现类 public class BeijingDinner extends AbstractDinner { public BeijingDinner(String name) { super(name); } @Override protected void beforeCooking() { System.out.printf(\"%sMM 在洗菜切菜\", name).println(); } @Override protected String doCooking() { return name + \"MM 在做\" + name + \"菜\"; } @Override protected void afterCooking() { System.out.printf(\"%sMM 让你去品尝\", name).println(); } } public class TaiwanDinner extends AbstractDinner { public TaiwanDinner(String name) { super(name); } @Override protected boolean foodEnough() { // 每次都买食物 return false; } @Override protected void doShopping() { System.out.println(\"生鲜超市购买，一定要买茶叶蛋\"); } @Override protected void beforeCooking() { System.out.printf(\"%sMM 在洗菜切菜\", name).println(); } @Override protected String doCooking() { return name + \"MM 在做\" + name + \"菜\"; } @Override protected void afterCooking() { System.out.printf(\"%sMM 让你去品尝\", name).println(); } } public class HangzhouDinner extends AbstractDinner { public HangzhouDinner(String name) { super(name); } @Override protected boolean foodEnough() { // 每次都买食物 return false; } @Override protected void beforeCooking() { System.out.printf(\"%sMM 在洗菜切菜\", name).println(); } @Override protected String doCooking() { return name + \"MM 在做\" + name + \"菜\"; } @Override protected void afterCooking() { System.out.printf(\"%sMM 让你去品尝\", name).println(); } } 定义了三个实现类，都实现了3个抽象方法。另外 TaiwanDinner 重写了另外两个方法，HangzhouDinner 只重写了 foodEnough。 2.1.4 运行例子 代码： public class DinnerDemo { public static void main(String[] args) { System.out.println(\"---准备台湾餐---\"); Dinner dinner1 = new TaiwanDinner(); dinner1.doDinner(); System.out.println(\"---准备杭州餐---\"); Dinner dinner2 = new HangzhouDinner(); dinner2.doDinner(); System.out.println(\"---准备北京餐---\"); Dinner dinner3 = new BeijingDinner(); dinner3.doDinner(); } } 输出结果： ---准备台湾餐--- 生鲜超市购买，一定要买茶叶蛋 台湾MM 在洗菜切菜 台湾MM 在做台湾菜 台湾MM 让你去品尝 台湾MM说：开吃喽 ---准备杭州餐--- 门口小贩买菜 杭州MM 在洗菜切菜 杭州MM 在做杭州菜 杭州MM 让你去品尝 杭州MM说：开吃喽 ---准备北京餐--- 北京MM 在洗菜切菜 北京MM 在做北京菜 北京MM 让你去品尝 北京MM说：开吃喽 ","date":"2019-11-09","objectID":"/zh-cn/design-template/:2:1","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/design-template/"},{"categories":["设计模式"],"content":"2.2 Golang 版本 声明下：在 golang 中，由于不存在抽象类和真正的继承，所以只能通过一个基础类来充当抽象类，子类通过组合基础类来实现通用方法的继承。 2.2.1 定义接口 type Dinner interface { DoDinner() } 2.2.2 定义抽象类 type AbstractCooking struct { foodEnough func() bool doShopping func() beforeCooking func() doCooking func() string afterCooking func() Name string } func (d *AbstractCooking) DoDinner() { if !d.foodEnough() { d.doShopping() } d.beforeCooking() fmt.Println(d.doCooking()) d.afterCooking() d.eat() } func (d *AbstractCooking) eat() { fmt.Println(fmt.Sprintf(\"%sMM说：开吃喽\", d.Name)) } 这里和 Java 不一样的地方是 go 的结构体可以拥有 func() 属性（也可以拥有接口属性）。 实现 Dinner 的方法 DoDinner , 编排了一系列的方法。 2.2.3 定义实现类 type HZDinner struct { AbstractCooking } func NewHZDinner(name string) *HZDinner { c := new(HZDinner) c.Name = name // 选择实现的 c.AbstractCooking.foodEnough = c.foodEnough c.AbstractCooking.doShopping = doShopping // 必须实现的 c.AbstractCooking.beforeCooking = c.beforeCooking c.AbstractCooking.doCooking = c.doCooking c.AbstractCooking.afterCooking = c.afterCooking return c } func (c *HZDinner) foodEnough() bool { return false } func (c *HZDinner) beforeCooking() { println(fmt.Printf(\"%sMM 在洗菜切菜\", c.Name)) } func (c *HZDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", c.Name, c.Name) } func (c *HZDinner) afterCooking() { println(fmt.Printf(\"%sMM 让你去品尝\", c.Name)) } type TWDinner struct { AbstractCooking } func NewTWDinner(name string) *TWDinner { c := new(TWDinner) c.Name = name // 选择实现的 c.AbstractCooking.foodEnough = c.foodEnough c.AbstractCooking.doShopping = c.doShopping // 必须实现的 c.AbstractCooking.beforeCooking = c.beforeCooking c.AbstractCooking.doCooking = c.doCooking c.AbstractCooking.afterCooking = c.afterCooking return c } func (c *TWDinner) foodEnough() bool { return false } func (c *TWDinner) doShopping() { fmt.Println(\"生鲜超市购买，一定要买茶叶蛋\") } func (c *TWDinner) beforeCooking() { println(fmt.Printf(\"%sMM 在洗菜切菜\", c.Name)) } func (c *TWDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", c.Name, c.Name) } func (c *TWDinner) afterCooking() { println(fmt.Printf(\"%sMM 让你去品尝\", c.Name)) } type BJDinner struct { AbstractCooking } func NewBJDinner(name string) *BJDinner { c := new(BJDinner) c.Name = name // 选择实现的 c.AbstractCooking.foodEnough = foodEnough c.AbstractCooking.doShopping = doShopping // 必须实现的 c.AbstractCooking.beforeCooking = c.beforeCooking c.AbstractCooking.doCooking = c.doCooking c.AbstractCooking.afterCooking = c.afterCooking return c } func (c *BJDinner) beforeCooking() { println(fmt.Printf(\"%sMM 在洗菜切菜\", c.Name)) } func (c *BJDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", c.Name, c.Name) } func (c *BJDinner) afterCooking() { println(fmt.Printf(\"%sMM 让你去品尝\", c.Name)) } 2.2.4 定义默认实现方法 func foodEnough() bool { return true } func doShopping() { fmt.Println(\"门口小贩买菜\") } 为什么有独立的默认方法，因为 struct 里面定义了 foodEnough() bool 和 doShopping() 两个方法，go 里面是不能重名的，因此不能再写属于 AbstractCooking 的方法。 func (d *AbstractCooking) foodEnough() bool { return true } 这个方法如何写了，去掉了 struct 的 foodEnough() bool，那么创建实现类的时候就没办法 c.AbstractCooking.foodEnough = c.foodEnough 进行 func() 赋值，从而 d.foodEnough() 会一直调用 AbstractCooking 下的 foodEnough()，实现类没办法自定义实现了。 2.2.5 运行例子 代码： func TestTemplate1(t *testing.T) { fmt.Println(\"---准备台湾餐---\") d1 := NewTWDinner(\"台湾\") d1.DoDinner() fmt.Println(\"---准备杭州餐---\") d2 := NewHZDinner(\"杭州\") d2.DoDinner() fmt.Println(\"---准备北京餐---\") d3 := NewBJDinner(\"北京\") d3.DoDinner() } 输出结果： ---准备台湾餐--- 生鲜超市购买，一定要买茶叶蛋 台湾MM 在洗菜切菜 台湾MM 在做台湾菜 台湾MM 让你去品尝 台湾MM说：开吃喽 ---准备杭州餐--- 门口小贩买菜 杭州MM 在洗菜切菜 杭州MM 在做杭州菜 杭州MM 让你去品尝 杭州MM说：开吃喽 ---准备北京餐--- 北京MM 在洗菜切菜 北京MM 在做北京菜 北京MM 让你去品尝 北京MM说：开吃喽 ","date":"2019-11-09","objectID":"/zh-cn/design-template/:2:2","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/design-template/"},{"categories":["设计模式"],"content":"2.3 Golang版本2 上面例子是在 struct 中定义，相当于是抽象方法的意思，而这版本把那部分方法都定义到了接口。 2.3.1 定义接口 type Dinner2 interface { foodEnough() bool doShopping() beforeCooking() doCooking() string afterCooking() } 2.3.2 定义抽象类 type AbstractDinner struct { } func (AbstractDinner) foodEnough() bool { return true } func (AbstractDinner) doShopping() { fmt.Println(\"门口小贩买菜\") } func (AbstractDinner) beforeCooking() { } func (AbstractDinner) doCooking() string { return \"\" } func (AbstractDinner) afterCooking() { } 实现 Dinner2 接口，和下面等价 type AbstractDinner struct { Dinner2 } func (AbstractDinner) foodEnough() bool { return true } func (AbstractDinner) doShopping() { fmt.Println(\"门口小贩买菜\") } 2.3.3 定义实现类 type HangzhouDinner struct { AbstractDinner } func NewHangzhouDinner(name string) Dinner2 { return \u0026HangzhouDinner{ AbstractDinner{ Name: name, }, } } func (d *HangzhouDinner) foodEnough() bool { return false } func (d *HangzhouDinner) beforeCooking() { fmt.Println(fmt.Sprintf(\"%sMM 在洗菜切菜\", d.Name)) } func (d *HangzhouDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", d.Name, d.Name) } func (d *HangzhouDinner) afterCooking() { fmt.Println(fmt.Sprintf(\"%sMM 让你去品尝\", d.Name)) } type BeijingDinner struct { AbstractDinner } func NewBeijingDinner(name string) Dinner2 { return \u0026BeijingDinner{ AbstractDinner{ Name: name, }, } } func (d *BeijingDinner) beforeCooking() { fmt.Println(fmt.Sprintf(\"%sMM 在洗菜切菜\", d.Name)) } func (d *BeijingDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", d.Name, d.Name) } func (d *BeijingDinner) afterCooking() { fmt.Println(fmt.Sprintf(\"%sMM 让你去品尝\", d.Name)) } type TaiwanDinner struct { AbstractDinner } func NewTaiwanDinner(name string) Dinner2 { return \u0026TaiwanDinner{ AbstractDinner{ Name: name, }, } } func (d *TaiwanDinner) foodEnough() bool { return false } func (d *TaiwanDinner) doShopping() { fmt.Println(\"生鲜超市购买，一定要买茶叶蛋\") } func (d *TaiwanDinner) beforeCooking() { fmt.Println(fmt.Sprintf(\"%sMM 在洗菜切菜\", d.Name)) } func (d *TaiwanDinner) doCooking() string { return fmt.Sprintf(\"%sMM 在做%s菜\", d.Name, d.Name) } func (d *TaiwanDinner) afterCooking() { fmt.Println(fmt.Sprintf(\"%sMM 让你去品尝\", d.Name)) } 2.3.4 定义模板方法 func DoDinner(d Dinner2) { if !d.foodEnough() { d.doShopping() } d.beforeCooking() fmt.Println(d.doCooking()) d.afterCooking() d.eat() } func (ad AbstractDinner) eat() { fmt.Println(fmt.Sprintf(\"%sMM说：开吃喽\", ad.Name)) } 如果想把抽象方法放到结构体上，也可以如下： type Dinner2 interface { ... DoDinner(d Dinner2) } func (ad AbstractDinner) DoDinner(d Dinner2) { if !d.foodEnough() { d.doShopping() } d.beforeCooking() fmt.Println(d.doCooking()) d.afterCooking() ad.eat() } func (ad AbstractDinner) eat() { fmt.Println(fmt.Sprintf(\"%sMM说：开吃喽\", ad.Name)) } 到时候调用的话就 DoDinner 改成 d1 := NewTaiwanDinner(\"台湾\") d1.DoDinner(d1)。 2.3.5 运行例子 代码： func TestTemplate2(t *testing.T) { fmt.Println(\"---准备台湾餐---\") d1 := NewTaiwanDinner(\"台湾\") DoDinner(d1) fmt.Println(\"---准备杭州餐---\") d2 := NewHangzhouDinner(\"杭州\") DoDinner(d2) fmt.Println(\"---准备北京餐---\") d3 := NewTaiwanDinner(\"北京\") DoDinner(d3) } 输出结果： ---准备台湾餐--- 生鲜超市购买，一定要买茶叶蛋 台湾MM 在洗菜切菜 台湾MM 在做台湾菜 台湾MM 让你去品尝 台湾MM说：开吃喽 ---准备杭州餐--- 门口小贩买菜 杭州MM 在洗菜切菜 杭州MM 在做杭州菜 杭州MM 让你去品尝 杭州MM说：开吃喽 ---准备北京餐--- 生鲜超市购买，一定要买茶叶蛋 北京MM 在洗菜切菜 北京MM 在做北京菜 北京MM 让你去品尝 北京MM说：开吃喽 ","date":"2019-11-09","objectID":"/zh-cn/design-template/:2:3","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/design-template/"},{"categories":["设计模式"],"content":"2.4、例子说明 ","date":"2019-11-09","objectID":"/zh-cn/design-template/:2:4","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/design-template/"},{"categories":["设计模式"],"content":"三、开源框架使用场景 列举某几个框架，供大家参考 ","date":"2019-11-09","objectID":"/zh-cn/design-template/:3:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/design-template/"},{"categories":["设计模式"],"content":"3.1 JDK AbstractList public abstract class AbstractList\u003cE\u003e extends AbstractCollection\u003cE\u003e implements List\u003cE\u003e { ... public void add(int index, E element) { throw new UnsupportedOperationException(); } ... public boolean addAll(int index, Collection\u003c? extends E\u003e c) { rangeCheckForAdd(index); boolean modified = false; for (E e : c) { add(index++, e); modified = true; } return modified; } ... } 实现类实现 add 的逻辑，如： public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable { // ... public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } // ... } ","date":"2019-11-09","objectID":"/zh-cn/design-template/:3:1","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/design-template/"},{"categories":["设计模式"],"content":"3.1 spring 中的 事务管理器 public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable { // ... public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException { Object transaction = doGetTransaction(); // Cache debug flag to avoid repeated checks. boolean debugEnabled = logger.isDebugEnabled(); if (definition == null) { // Use defaults if no transaction definition given. definition = new DefaultTransactionDefinition(); } if (isExistingTransaction(transaction)) { // Existing transaction found -\u003e check propagation behavior to find out how to behave. return handleExistingTransaction(definition, transaction, debugEnabled); } // Check definition settings for new transaction. if (definition.getTimeout() \u003c TransactionDefinition.TIMEOUT_DEFAULT) { throw new InvalidTimeoutException(\"Invalid transaction timeout\", definition.getTimeout()); } // No existing transaction found -\u003e check propagation behavior to find out how to proceed. if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) { throw new IllegalTransactionStateException( \"No existing transaction found for transaction marked with propagation 'mandatory'\"); } else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED || definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW || definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) { SuspendedResourcesHolder suspendedResources = suspend(null); if (debugEnabled) { logger.debug(\"Creating new transaction with name [\" + definition.getName() + \"]: \" + definition); } try { boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); doBegin(transaction, definition); prepareSynchronization(status, definition); return status; } catch (RuntimeException ex) { resume(null, suspendedResources); throw ex; } catch (Error err) { resume(null, suspendedResources); throw err; } } else { // Create \"empty\" transaction: no actual transaction, but potentially synchronization. if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT \u0026\u0026 logger.isWarnEnabled()) { logger.warn(\"Custom isolation level specified but no actual transaction initiated; \" + \"isolation level will effectively be ignored: \" + definition); } boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS); return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null); } } // ... protected abstract void doBegin(Object transaction, TransactionDefinition definition) throws TransactionException; ... } 这里只拿 getTransaction 和 doBegin 举例，非常标准的写法 getTransaction 还用了 final 描述，表示子类不允许改变。 当我自定义事务管理器的时候，比如每次事务开启创建一个 traceId，效果如下： public class GongDaoDataSourceTransactionManager extends DataSourceTransactionManager implements ResourceTransactionManager, InitializingBean, EnvironmentAware { // ... protected void doBegin(Object transaction, TransactionDefinition definition) { String currentXid; if (XIDContext.getCurrent() != null \u0026\u0026 null != XIDContext.getCurrent().getId()) { currentXid = xidGenerator.getXID(); XIDContext.childCurrent(new TransactionContent(currentXid, definition.getName())); } else { currentXid = xidGenerator.getXID(); XIDContext.setXid(new TransactionContent(currentXid, definition.getName())); } if (null == HyjalTransactionFileAppender.contextHolder.get()) { String logFileName = HyjalTransactionFileAppender.makeLogFileName(new Date(), HyjalTransactionFileAppender.logId.get()); HyjalTransactionFileAppender.contextHolder.set(logFileName); } try { if (null == XIDContext.getCurrentXid()) { XIDContext.setXid(xidGenerator.getXID()); } super.doBegin(transaction, definition); } finally { if (logger.isDebugEnabled()) { logger.debug(\"do begin Xi","date":"2019-11-09","objectID":"/zh-cn/design-template/:3:2","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/design-template/"},{"categories":["设计模式"],"content":"四、优势和劣势 ","date":"2019-11-09","objectID":"/zh-cn/design-template/:4:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/design-template/"},{"categories":["设计模式"],"content":"4.1 优势 对扩展开放，对修改关闭，符合“开闭原则” 定义标准算法，子类可自定义扩展，把变性和不变性分离 子类的扩展不会导致标准算法结构 能够提高代码复用，公共部分易维护 ","date":"2019-11-09","objectID":"/zh-cn/design-template/:4:1","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/design-template/"},{"categories":["设计模式"],"content":"4.2 劣势 每一个实现类都需要定义自己的行为，如果复杂业务实现类会膨胀的比较多 ","date":"2019-11-09","objectID":"/zh-cn/design-template/:4:2","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/design-template/"},{"categories":["设计模式"],"content":"五、参考 https://www.tutorialspoint.com/design_pattern/template_pattern.htm https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95 ","date":"2019-11-09","objectID":"/zh-cn/design-template/:5:0","tags":["java","golang","模板方法模式"],"title":"闲聊设计模式 | 模板方法模式","uri":"/zh-cn/design-template/"}]